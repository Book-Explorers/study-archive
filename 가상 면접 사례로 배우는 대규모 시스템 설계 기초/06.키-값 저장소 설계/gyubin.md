# 키-값 저장소

## 키-값 저장소
고유 식별자를 키와 값 사이의 연결 관계(pair)를 가지는 비관계형 데이터베이스이다.
## 분산 키-값 저장소
분산 해시 테이블이라고도 불리며, 키-값 쌍을 여러 서버에 분산시킨다.
이 시스템을 설계하기 전에 CAP 정리를 이해하고 있어야 한다.
#### CAP 정리
CAP 정리는 데이터 일관성(consistency), 가용성(avaliability), 파티션 감내(partition tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리이다.  각 의미는 다음과 같다.

- 데이터 일관성(consistency)
    - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
- 가용성(avaliability)
    - 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야 한다.
- 파티션 감내(partition tolerance)
    - 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라고 시스템은 계속 동장해야 한다는 것을 뜻한다.

키-값 저장소는 파티션 문제를 감내할 수 있도록 설계 되어야 하기 때문에 CA(consistency, availability) 시스템은 고려하지 않으며 요구사항에 따라 CP(consistency, partition tolerance), AP(availability, partition tolerance) 시스템을 설계해야 한다.
## 키-값 저장소에서 사용되는 핵심 컴포넌트
#### 데이터 파티션
5장에서 다룬 안정 해시(consistent hash)를 사용하여 데이터를 여러 서버에 고르게 분산하고 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있다.

안정 해시를 사용하여 데이터를 파티션하면 좋은 점은 다음과 같다.
- 규모 확장 자동화(automatic scaling)
    - 안정 해시는 각 서버의 데이터와 키를 동일한 해시 공간(해시 링)에 매핑하는 방식이기 때문에 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
- 다양성(heterogeneity)
    - 각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.
#### 데이터 다중화
고가용성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화(replication)할 필요가 있다. N개 서버를 선정하는 방법은 key를 해시 링위에 배치한 후, 그 지점으로 부터 시계 방향으로 링을 순회하면서 만나는 N개의 서버를 선정한다. 서버를 선정할 때 동일한 서버의 가상 노드를 선택하여 같은 서버가 중복으로 선택되지 않도록 주의해야 한다.

❗️N개 서버에 비동기적으로 다중화할 때 어떤 기술을 사용할까? kafka connect를 사용한 CDC(Change Data Capture)?
## 데이터 일관성
데이터 다중화로 각 서버에 다중화된 데이터는 적절히 동기화가 되어야 한다. 정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.

- N
    - 사본 개수
- W
    - 쓰기 연산에 대한 정족수
    - 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.
    - 카프카의  min.insync.replicas 옵션과 비슷한 개념 같다.
    - kafka broker가 3개인 경우 acks=-1, min.insync.replicas=2로 설정하면 토픽 파티션의 리더가 프로듀서에게 ack 응답을 보내기 위해 최소 2대의 팔로워로부터 레코드 복제가 완료되었다는 응답을 받아야 한다.
- R
    - 읽기 연산에 대한 정족수
    - 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다

요구되는 일관성 수준에 따라 W, R, N의 값을 조정해야 한다.
- R = 1, W = N
    - 빠른 읽기 연산에 최적화된 시스템
- R = N, W = 1
    - 빠른 쓰기 연산에 최적화된 시스템
- R + W > N
    - 강한 일관성이 보장되는 시스템 (보통 N = 3, W = R = 2)
- R + W <= N
    - 강한 일관성이 보장되지 않는 시스템
      ❗️kafka broker가 3개인 경우 acks=-1, min.insync.replicas=3로 설정하면 하나의 broker가 장애가 발생하는 경우 레플리케이션 조건을 충족시킬 수 없기 때문에 broker들은 더 이상 레코드를 받지 못 하고 전체적인 장애로 이어진다. 그렇기 때문에 min.insync.replicas는 broker - 1 이하의 값으로 설정해야 한다.
#### 일관성 모델
- 강한 일관성(strong consistency)
    - 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환해야만 한다.
    - N개의 서버에 동기화가 될 때까지 해당 데이터에 대한 읽기/쓰기를 금지시키게 설계한다.
- 약한 일관성(weak consistency)
    - 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
    - N개의 서버에 동기화 여부와 상관없이 해당 데이터에 대한 읽기/쓰기를 수행할 수 있기 때문에 쓰기 요청을 받은 서버에서 쓰기 연산을 처리하고 바로 응답을 주도록 구현하고 나머지 N개의 서버에 동기화는 비동기적으로 동기화를 수행하도록 설계할 수 있을 거 같다.
- 최종 일관성(eventual consistency)
    - 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영된다.
    - 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있다. 이러한 문제는 클라이언트가 해결해야 한다.
    - 이러한 비 일관성 문제는 데이터 버저닝과 백터 시계를 사용하여 해결할 수 있다.
## 장애 처리
#### 장애 감지
분산형 장애 감지 솔루션인 가십 프로토콜(gossip protocol)을 사용하면 효율적으로 장애 감지를 할 수 있다.
가십 프로토콜의 동작 원리는 다음과 같다.
- 각 노드는 멤버십 목록을 유지하며, 멤버십 목록은 멤버 ID와 heartbeat counter 쌍의 목록이다.
- 각 노드는 주기적으로 자신의 heartbeat counter를 증가시킨다.
- 각 노드는 무작위로 선정된 노드들에게 주기적으로 자신과 오랫동안 증가되지 않은 노드의 heartbeat counter를 보낸다.
- heartbeat counter를 받은 노드는 멤버십 목록을 최신 값으로 갱신하고 오랫동안 heartbeat counter가 증가되지 않은 노드에 대해서 장애 노드로 표시한다.

감시된 장애는 장애 해소 전략인 일시적 장애 처리 또는 영구 장애 처리를 통해 처리할 수 있다.(p107 ~ p110)

## 쓰기 경로와 읽기 경로
#### 쓰기 경로
쓰기 요청 처리는 다음과 같다.
- 쓰기 요청은 커밋 로그 파일에 기록된다.
- 데이터가 메모리 캐시에 기록된다.
- 메모리 캐시가 가득차거나 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.
###### SSTable
키-값 쌍을 항상 정렬된 리스트로 관리하는 테이블이다. 항상 정렬이 되어 관리가 되기 때문에 효율적이고 빠른 검색 및 범위 쿼리를 가능하게 한다. 쓰기 작업은 메모리에 존재하는 Memtable에 먼저 기록하고 일정 시간 또는 Memtable의 크기가 일정 한도에 도달하면 배치 처리하여 성능을 향상시킨다.

https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/
#### 읽기 경로
읽기 요청 처리는 다음과 같다.
- 데이터가 메모리에 있는지 검사한다.
- 데이터가 메모리에 없으면 블룸 필터를 검사한다.
- 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸 후 SSTable에서 데이터를 가져온다.
- 해당 데이터를 클라이언트에게 반환한다.
###### Bloom Filter
확률적 데이터 구조로 주로 데이터베이스나 캐시 시스템에서 특정 요소가 집합에 존재하는지를 빠르게 검사하는데 사용된다.

SSTable 생성 시 각 키를 Bloom Filter 비트 배열에 저장하는데 이때 각 키에 대해 여러 해시 함수를 사용하여 비트 배열의 인덱스를 구하고 해당 인덱스의 비트를 1로 설정한다. 비트 배열을 사용하기 때문에 메모리 사용량이 적고 빠른 검색이 가능하다.

검색 과정은 Bloom Filter 비트 배열에 저장했을 때 사용했던 동일한 여러 해시 함수로 키에 대해 배열의 인덱스를 구한 후 모든 인덱스의 비트가 1이면 SSTable에 접근하고 하나라도 0이면 다른 SSTable의 Bloom Filter 비트 배열을 검사한다.