# 6. 단위 테스트 스타일

## 목차

- 단위 테스트의 스타일 비교
- 함수형 아키텍처와 육각형 아키텍처의 관계
- 출력 기반 테스트로 전환

## 단위 테스트의 세 가지 스타일

- 출력 기반 테스트
    - SUT의 입력을 넣고 생성되는 출력을 점검하는 방식. 이러한 테스트는 전역 상태나 내부 상태를 변경하지 않는 즉, 사이드 이팩트가 없는 함수형 프로그래밍을 적용한 코드에만 적용되므로 반환 값만 검증하면된다.
- 상태 기반 테스트
    - 작업이 완료된 후 시스템의 상태를 확인하는 방식. 상태는 SUT나 협력자 중 하나 또는 DB나 file system과 같은 외부 의존성의 상태를 의미한다.
- 통신 기반 테스트
    - 목을 사용해 SUT와 협력자 간의 통신을 검증하는 방식.

❗️협력자란 공유 의존성 또는 변경 가능한 비공개 의존성을 말한다.

고전파와 런던파는 출력 기반 테스트를 사용하고 고전파는 통신 기반 테스트 보다 상태 기반 테스트를 선호하며 런던파는 상태 기반 테스트 보다 통신 기반 테스트를 선호한다.

## 단위 테스트 스타일 비교

출력, 상태, 통신 기반 테스트를 좋은 단위 테스트의 4대 요소인 회귀 방지, 리팩토링 내성, 빠른 피드백, 유지 보수성을 가지고 비교해 보도록 하자.

### 회귀 방쥐와 피드백 속도 지표로 스타일 비교하기

회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다. 회귀 방지 지표는 다음 세 가지 특성으로 결정된다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성
    - 코드가 다루고 있는 데이터, 기능, 규칙이 해당 도메인의 요구사항과 비즈니스 규칙을 정확하게 반영하고 있는 지를 의미

단위 출력, 상태, 통신 기반 테스트에서는 회귀 방지와 피드백 속도 지표가 차이가 거의 없기 때문에 비교하는 의미가 없다. 그 이유는 테스트 스타일과 관계 없이 코드의 양이 적든 많든 원하는 대로 테스트를 작성할 수 있고 코드의 복잡도와 도메인의 유의성은 코드를 작성하는 개발자에 따라 차이가 심하기 때문에 어떤 테스트 스타일도 이 세 가지 부분에서는 도움이 되지 않는다. 또한 테스트가 프로세스 외부 의존성과 격리된 단위 테스트 영역에 있는 한, 모든 스타일은 테스트의 실행 속도가 거의 동일하다.

### 리팩토링 내성 지표로 스타일 비교하기

리팩토링 내성은 리팩토링 중 발생하는 거짓 양성(허위 경보) 수에 대한 척도다. 거짓 양성은 식별할 수 있는 동작이 아니라 구현 세부 사항에 결합된 테스트로인해 발생한다.

**출력 기반 테스트의 리팩토링 내성 지표**

출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.

이러한 테스트가 구현 세부 사항에 결합하는 경우는 테스트 대상 메서드가 구현 세부 사항일 때뿐이다.

**상태 기반 테스트의 리팩토링 내성 지표**

상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 이 테스트는 테스트 대상 메서드 외에도 클래스 내부 상태를 검증해야 하기 때문에 테스트와 코드 베이스 간의 결합도가 커지게 된다. 결합도가 커지면 유출되는 구현 세부 사항(큰 API)에 테스트가 얽매일 가능성이 커지게 되며 이로인해 리팩토링 내성이 저하된다.

**통신 기반 테스트의 리팩토링 내성 지표**

통신 기반 테스트가 거짓 양성에 가장 취약하다. 테스트 대역으로(특히 스텁) 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다. 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 사이드 이팩트가 외부 환경에 보이는 경우에만 목이 괜찮다.

### 유지 보수성 지표로 스타일 비교하기

유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있지만, 리팩토링 내성과 달리 완화할 수 있는 방법이 많지 않다. 유지 보수성은 단위 테스트의 유지비를 측정하며, 다음 두 가지 특성으로 정의한다.

- 테스트를 이해하기 얼마나 어려운가?
    - 테스트 크기와 관련
- 테스트를 실행하기 얼마나 어려운가?
    - 테스트가 직접적으로 관련 있는 프로세스 외부 의존성 수와 관련

테스트가 크면, 파악하기도 변경하기도 어려우므로 유지 보수가 쉽지 않다. 마찬가지로 하나 이상의 프로세스 외부 의존성과 직접 작동하는 테스트도 실행하기 쉽지 않기 때문에 유지 보수가 어렵다.

**출력 기반 테스트의 유지 보수성**

출력 기반 테스트가 가장 유지 보수하기 용이하다. 메서드로 입력을 공급하는 것과 해당 출력을 검증하는 두 가지로 요약이 가능하기 때문에 테스트 코드가 거의 항상 짧고 간결하므로 유지 보수가 쉽다. 또한 테스트 대상 메서드는 전역 상태나 내부 상태를 변경할 리 없으므로(함수형 프로그래밍), 프로세스 외부 의존성을 다루지 않는다. 따라서 두 가지 유지 보수성 모두의 측면에서 출력 기반 테스트가 가장 좋다.

**상태 기반 테스트의 유지 보수성**

출력 기반 테스트 보다 유지 보수가 쉽지 않다. 상태 검증은 종종 출력 검증보다 더 많은 코드가 필요하기 때문이다.

검증 코드를 단축하는 헬퍼 메서드를 사용해서 완화할 수 있지만 그럼에도 불구하고 출력 기반 테스트 보다 유지 보수성이 떨어진다.

**통신 기반 테스트의 유지 보수성**

세 가지 테스트 스타일 중 유지 보수성이 가장 떨어진다. 테스트 대역과 상호 작용 검증을 설정해야 하며 목이 체이닝 형태로 있을 때 테스트는 더 커지고 유지 보수하기 어려워진다.

**스타일 비교하기: 결론**

결론은 출력 기반 테스트가 가장 결과가 좋다. 이 스타일은 구현 세부 사항과 거의 결합되지 않으므로 리팩토링 내성을 적절하게 유지하고자 신경을 많이 쓸 필요가 없다. 이러한 테스트는 간결하고 프로세스 외부 의존성이 없기 때문에 유지보수도 쉽다.

|  | 출력 기반 | 상태 기반 | 통신 기반 |
| --- | --- | --- | --- |
| 리팩토링 내성을 지키기 위해 필요한 노력 | 낮음 | 중간 | 중간 |
| 유지비 | 낮음 | 중간 | 높음 |

## 함수형 아키텍처 이해

### 함수형 프로그래밍이란?

함수형 프로그래밍이란 수학적 함수(순수 함수)를 사용한 프로그래밍이다.

수학적 함수는 숨은 입출력이 없는 함수(메서드)다. 모든 입출력은 메서드의 이름, 인수, 반환 타입으로 구성된 시그니처에 명시해야 한다. 또한 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성해야 한다.

숨은 입출력에 대해서 지피티한테 물어봄.

![스크린샷 2024-03-14 오후 8 27 27](https://github.com/rbsks/unit_test/assets/67041069/c1dd3798-8385-4f49-9b0e-d9bee1ad966d)

입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 테스트하기가 매우 쉽다. 즉, 유지 보수성이 뛰어나고 거짓 양성이 빈도가 낮다. **출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다.**

반면에 숨은 입출력이 있는 코드는 테스트하기 힘들고 가독성도 떨어진다. 숨은 입출력의 유형은 다음과 같다.

- 사이드 이팩트
    - 메서드 시그니처에 포함되지 않은 출력이며 메서드에서 인스턴스의 상태를 변경하거나 디스크, 데이터베이스의 상태를 변경하는 등의 사이드 이팩트를 발생시킨다.
- 예외
    - 메서드가 예외를 던지면 시그니처에 포함되지 않은 출력이 포함될 수 있다.
- 내외부 상태에 대한 참조
    - 정적 속성을 사용하거나, 데이터베이스에서 질의를 하거나 클래스내의 비공개 인스턴스 멤버를 참조하는 경우는 메서드 시그니처에 없는 실행 흐름에 대한 입력이다.

메서드가 수학적 함수인지 판별하는 가장 좋은 방법은 프로그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환 값으로 대체할 수 있는지 확인하는 것이다. 메서드의 호출을 해당 값으로 바꾸는 것을 참조 투명성이라고 한다.

### 함수형 아키텍처란?

함수형 프로그래밍의 목표는 사이드 이팩트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 사이드 이팩트를 일으키는 코드를 분리하는 것이다. 즉, 책임을 분리하는 것이다. 사이드 이팩트를 비즈니스 로직 외부로 몰아서 사이드 이팩트와 비즈니스 로직을 분리한다.

다음 두 가지 코드 유형을 구분해서 비즈니스 로직과 사이드 이팩트를 분리할 수 있다.

- 결정을 내리는 코드
    - 수학적 함수를 사용해 사이드 이팩트가 없게 작성한다. 함수형 코어라고도 불림.
- 해당 결정에 따라 적용하는 코드
    - 함수형 코어에서 이뤄진 모든 결정을 데이터베이스와 같은 프로세스 외부 의존성에 사이드 이팩트를 적용시킨다. 가변 셀이라고도 불림.

![스크린샷 2024-03-14 오후 9 11 42](https://github.com/rbsks/unit_test/assets/67041069/74e5ef08-c684-478e-90c9-a0445991abb0)

함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.

- 가별 셸은 모든 입력을 수집한다.
- 함수형 코어는 결정을 생성한다.
- 가변 셸은 함수형 코어에서 이뤄진 결정을 사이드 이팩트로 변환한다.

이 두 계층을 잘 분리하려면, 가변 셸이 추가적인 의사 결정을 내리지 않게 끔 함수형 코어 입력에 충분한 정보가 주어 졌는지 확인해야 한다.즉, 가변 셸은 가능한 아무 의사결정도 하면 안된다. **목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셀은 훨씬 더 적은 통합 테스트에 맡기는 것이다.**

### 함수형 아키텍처와 헥사고날 아키텍처 비교

함수형 아키텍처와 헥사고날 아키텍처 둘 다 관심사의 분리라는 아이디어를 기반으로 한다.

또 다른 유사점은 의존성 간의 단방향 흐름이다. 헥사고날 아키텍처에서는 도메인 계층내 클래스는 서로에게만 의존해야하며, 애플리케이션 서비스 계층 클래스에는 의존하면 안된다. 마찬가지로 함수형 아키텍처에서도 불변 코어(함수형 코어)는 가변 셸에 의존하지 않는다. **외부 계층과 격리돼 작동할 수 있기 때문에 테스트하기 쉬우며 가변 셸에서 불변 코어를 완전히 떼어내 가변 셸이 제공하는 입력을 단순한 값으로 모방할 수 있다.**

이 둘의 차이점은 사이드 이팩트에 대한 처리에 있다. 함수형 아키텍처는 모든 사이드 이팩트를 불변 코어에서 비즈니스 연산 가장자리인 가변 셸로 밀어내어 가변 셸이 처리한다. 반면 헥사고날 아키텍처는 해당 도메인 계층에서 발생하는 사이드 이팩트는 문제없다. 헥사고날 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘어서는 안된다. 예를 들어 도메인 인스턴스는 데이터베이스에 직접 저장하거나 수정할 수 없지만 자체 상태를 변경할 수는 있다. 이러한 변경은 애플리케이션 서비스 계층에서 데이터베이스에 적용한다.