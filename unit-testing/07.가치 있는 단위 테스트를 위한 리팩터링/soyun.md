# 07 가치있는 단위 테스트를 위한 리팩터링

<aside>
💡 7장에서 다루는 내용
네 가지 코드 유형 알아보기
험블 객체 패턴 이해
가치 있는 테스트 작성

</aside>

가치있는 테스트 식별

가치 있는 테스트 작성

그냥 작성에서 코드 설계 기법을 통해 작성.

가치있는 테스트를 위해서는 코드메이스에 노력 기울여야 한다. 

6장에서 배운 것 - 코드 베이스를 전환하는 법. (기존 시스템을 함수형 아키텍처로 재설계)

이 장에서는 함수형 아키텍처를 사용할 수 없는 애플리케이션 등에 대한 방식으로 일반화한다. 

즉 대다수 소프트웨어 프로젝트에서 가치 있는 테스트를 작성하는 방법과 실용적 지침을 알아보자

## 7.1 리팩터링할 코드 식별하기

## 7.1.1 코드의 네 가지 유형

모든 제품 코드는 2차원으로 분류할 수 있다. 

- 복잡도 또는 도메인 유의성
    
    코드 복잡도 code complexity : 코드 내 의사결정(분기) 지점 수로 정의한다. 이 숫자가 클수록 복잡도는 더 높아진다. 
    
    도메인 유의성 domain significance: 코드가  프로젝트의 문제 도메인에 얼마나 의미있는지를 나타낸다.
    
    (일반적으로 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관성이 있으므로 도메인 유의성이 높다. 반면 유틸리티 코드는 그런 연관성이 없다. )
    
    “복잡한 코드와 도메인 유의성을 갖는 코드가 해당 테스트가 회귀 방지가 뛰어나기 때문에 단위 테스트에서 가장 이롭다.”
    
    - 복잡한 코드와 도메인 유의성 특성은 서로 독립적이다.
        
        주문 가격을 계산하는 메서드에 조건문이 없다면 순환 복잡도는 1이다. 그러나 이러한 메서드는 비즈니스에 중요한 기능이므로 테스트하는 것이 중요하다. 
        
- 협력자 수
    
    클래스 또는 메서드가 가진 협력자 수. 협력자는 가변 의존성이거나 프로세스 외부 의존성 (또는 둘다 )이다.
    
    협력자가 많은 코드드테스트 비용이 많이 든다. 테스트 크기에 따라 달라지는 유지 보수성 지표때문이다.
    
    협력자의 유형도 중요하다. 도메인 모델이라면 프로세스 외부 협력자(목)를 사용하면 안된다. 목체계가 복잡해 유지비가 많이 들기 때문이다. 리팩터링 내성을 잘 지키기 위해서는 신중하게 목을 사용해야하는데 
    
    “목은 애플리케이션 경계를 넘는 상호 작용을 검증하는데만 사용해야한다(5장 참조)”
    
    프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는 것이 좋다. 그러면 도메인 클래스는 프로세스 내부 의존성에만 동작하게 된다. 
    
    협력자 수를 세는데에는 암시적 협력자, 명시적 협력자 모두 포함된다. 
    
    테스트 대상 시스템SUT이 협력자를 인수로 받거나 정적 메서드를 통해 암시적으로 참조해도 상관없지만 테스트에서 이 협력자를 설정해야한다. 
    

코드 복잡도, 도메인 유의성, 협력자 수의 조합으로 네 가지 코드 유형을 볼 수 있다. 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe9b8166-b5d9-4798-b656-ce481ba3f932/2a8a103c-78a2-4278-b1b8-ffcd0657f7fb/Untitled.png)

- 도메인 모델과 알고리즘 : 단위 테스트하면 노력대비 가장 이롭다. 협력자가 거의 없어서 테스트 유지비를 낮추기 때문에 저렴
- 간단한 코드 : 테스트할 필요가 전혀없다. 테스트가치가 0에 가깝다.
- 컨트롤러
- 지나치게 복잡한 코드 : 가장 문제가 되는 코드 유형, 단위 테스트가 어렵겠지만 테스트 커버리지없이 내버려두는 것은 너무 위험하다.

팁 | 코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야한다. 

지나치게 복잡한 코드를 피하고 도메인 모델과 알고리즘과 컨트롤러로 나눠서 리팩터링하라

## 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

지나치게 복잡한 코드를 쪼개러면 험블객체 Humble object패턴을 써야한다. 

어려운 의존성과 결합된 코드는 테스트하기 어렵다. 테스트는 해당 의존성도 다뤄야하기 때문에 유지비가 증가한다. 

험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 

코드를 테스트할 필요가 없도록 간단하게 만든다. 

이런 패턴은 육각형 아키텍처, 함수형 아키텍처에서도 모두 같이 구현하고 있는 패턴이다. 

육각형 아키텍처는 도메인 계층(비즈니스 로직)과 애플리케이션 서비스 계층(프로세스 외부 의존성)과의 통신을 분리한다.

함수형 아키텍처는 더 나아가 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 커뮤니케이션에서 비즈니스 로직을 분리한다. 

험블객체 패턴을 보는 또 다른 방법은 단일책임원칙Single Responsibility principle SRP를 지키는 것이다. 이는 각 클래스가 단일한 책임만 가져아한다는 원칙이다. 

특정상황은 비즈니스 로직과 오케스트레이션(많은 협력자를 가짐)을 분리하는 경우다. 

즉 코드가 깊거나(복잡하고 중요) 넓을(많은 협력자와 작동)수 있지만 둘 다 가능하지 않다. 

도메인계층 및 알고리즘은 코드가 깊지만 컨트롤러는 많은 의존성을 조정해 코드가 넓다.

이런 분리가 중요하다. 

이런 패턴의 다른 예로

MVP model view presenter와 MVC model view controller패턴이 있다.

이 두패턴은 비즈니스 로직(모델) , UI관심사(뷰) , 그리고 모델과 뷰사이의 조정(프리젠터 또는 컨트롤러)을 분리하는데 도음 된다. 

또 다른 예로

도메인주도 설계 Domain Driven Design에 나오는 집계 패턴Aggregate pattern이 있다. 

그 목표 중 하나는 클래스를 클러스터(집계)로 묶어서 클래스 간의 연결을 줄이는 것이다.

## 7.2 가치있는 단위 테스트를 위한 리팩터링하기

1. 이메일 변경이라는 단 하나의 유스케이스가 있다.
2. 비즈니스 규칙을 확인
    1. 사용자의 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객으로 간주한다. 
    2. 시스템은 회사의 직원수를 추적해야한다. 사용자 유형이 직원에서 고객으로 또는 그 반대로 변경되면 이 숫자도 변경해야한다. 
    3. 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야한다. 

초기 CRM (고객관리시스템) 구현은

User 도메인 클래스 내부에서 

changeEmail 메서드 내부에서 

데이터베이스에서 사용자의 현재 이메일과 유형 검색

데이터베이스에서 조직의 도메인 이름과 직원 수 검색

새 이메일의 도메인 이름에 따라 사용자 유형 설정

필요한 경우 조직의 직원수 업데이트

데이터베이스에 사용자 저장

메시지 버스에 알림전송

을 진행했다. 이 User클래스는 현재 지나치게 복잡한 코드이다. 

네 개의 의존성을 가졌다. 

명시적 의존성 userId, newEamil인수(이 둘은 값이므로 클래스의 협력자수에는 포함되지 않는다.)

암시적 의존성은 Database, MessageBus이다. 이 둘은 프로세스 외부 협력자이다. 

도메인 유의성이 높은 코드에서 프로세스 외부 협력자를 사용하면 안된다!

## 7.2.2 1단계 암시적 의존성을 명시적으로 만들기

데이터베이스, 메시지 버스에 대한 인터페이스를 만들고

인터페이스를 User에 주입한 후 테스트에서 목으로 처리한다. 

하지만 여전히 해당 의존성은 프로세스 외부에 있다.

## 7.2.3 2단계: 애플리케이션 서비스 계층 도입

도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하기 위해 다른 클래스인 험블 컨트롤러로 책임을 옮겨야한다. 

일반적으로 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존해야한다. 

UserController클래스를 만들어서 

Database, messageBus를 가져와 처리한다. 

User클래스로부터 프로세스 외부 의존성과의 작업 줄이는데 도움이 됐으나 몇가지 문제가 있다. 

- 프로세스 외부 의존성이 주입되지 않고 직접 인스턴스화된다. 이는 통합테스트에서 문제가 될 것
- 컨트롤러는 디비에서 받은 원시데이터를 User인스턴스로 재구성한다. 이는 복잡한 로직이므로 애플리케이션 서비스에 속하면 안된다.
- 회사 데이터인 회사 직원수는 사용자와 관련이 없다. 즉 책임은 다른 곳에 있다.
- 컨트롤러는 새로운 이메일과 전과 다른지 여부와 상관없이 무조건 데이터를 수정해서 저장하고 메시지 버스에 알람을 보낸다.

## 7.2.3 3단계: 애플리케이션 서비스 복잡도 낮추기

UserController가 컨트롤러 사분면에 확실히 있으려면 재구성 로직을 추출해야한다. ORM객체관계 매핑 라이브러리를 사용해 디비를 도메인 모델에 매핑하면 재구성 로직을 옮기기에 적절한 위치가 될 수 있다. 

모든 ORM 라이브러리는 데이터베이스 테이블을 도메인 클래스에 어떻게 매핑하는지를 지정할 수 있게 한다. 

ORM을 사용하거나 않거나 사용할 수 없으면 

도메인 모델에 

원시 데이터베이스 데이터로 

도메인 클래스를 인스턴스화 할 수 있는 팩토리 클래스를 작성하라

이 팩토리 클래스는 별도 클래스가 될 수도 있고, 더 간단한 경우 기존 도메인 클래스의 정적 메서드가 될 수도 있다. 샘플 애플리케이션의 재구성 로직이 그다지 복잡하지 않지만 분리해두는 것이 좋기 때문에 다음 예제와 같이 별도의 UserFactory 클래스를 둔다.

```java
public Class UserFactory
{
	public static User Create(Object[] data)
	
	{
		Precondition.Requires(data.Length >= 3);
		
		int id = (int) data[0];
		string email = (string) data[1];
		UserType type = (UserType) data[2];
		
		return new User(id,emil,type);
	}
}

```

? 그러면 디비값을 받아서 User인스턴스로 만들어주는 클래스인데 

ORM은 아니지만 매퍼에서도 이미 도메인 클래스로 디비값이 담겨져서 안해도 되지 않을까..

하는 생각.  맞나?

근데 분리하는 목적이니까 의미가 있나?

이 코드는 이제 모든 협력자와 완전히 격리돼 있으므로 테스트가 쉬워졌다. 

이 메서드에는 데이터 배열에 최소 세 개의 요소가 있어야한다는 요구사항에 대한 안전장치가 있다(오 유효성검증같은건가)

Precondition은 불리언 인수가 false인 경우 예외를 발생시키는 간단한 사용자 정의 클래스이다.

이 재구성 로직은 다소 복ㄱ잡하지만 도메인 유의성이 없다. 사용자 이메일을 변경하려는 클라이언트의 목표와 직접적인 관련이 없다. 이는 이전장에서 언급한 유틸리티 코드의 예다. 

## 7.2.3 4단계: 애플리케이션 서비스 복잡도 낮추기

복잡도 또는 도메인 유의성

- 분기점이 많으면 복잡도가 높아진다
- 도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미있는지 나타낸다.

협력자 수

- 도메인은 프로세스 외부 의존성을 가지면 안된다.
- 리팩터링 내성을 잘 지킬려면 애플리케이션 경계를 넘는 상호 작용 중 외부 프로젝트에서 사이드 이펙트가 보이는(식별

- 도메인 모델과 알고리즘
    - 코드에
- 험블객체 패턴: 복잡한 코드를 어플리케이션(프로세스 외부의존성있는), 도메인 코드(상태,비즈니스 로직관리) 나눠서

컨트롤러에서 조건부 로직처리

비즈니스 로직과 오케스트레이션(외부 의존성 많이 호출하는 다양한 협력자들과 작동하는 코드)

- 저장소에서 데이터 검색(오케스트레이션)
- 비즈니스 로직 실행
- 데이터를 다시 저장소에 검색
