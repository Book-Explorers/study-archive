```jsx
단위 테스트 스타일 비교
함수형 아키텍처와 육각형 아키텍처의 관계
출력 기반 테스트로 전환
```

이 장에서는 단위 테스트 스타일에 대해  

세 가지 테스트 스타일을 기준으로 틀을 적용할 것이다. 

- 출력 기반
- 상태 기반
- 통신 기반

# 6.1 단위테스트의 세 가지 스타일

### 1. 출력 기반 output-based testing

테스트 품질이 가장 좋다. 

순수 함수 방식으로 작성된 코드에만 적용된다. 

출력 기반 스타일로 변환하기 위해 “함수형 프로그래밍 원칙”을 사용해 기반 코드가 “함수형 아키텍처”를 지향하게끔 재구성해야한다. 

### 2. 상태 기반 state-based testing

두 번째로 좋음

### 3. 통신 기반 communication-based testing

간헐적으로만 사용해야 한다

하나의 테스트에서 여러 스타일을 모두 사용할 수 있다. 

# 6.1.1 출력 기반 테스트 정의

테스트 대상 시스템 SUT에 입력을 넣고 생성되는 출력을 점검하는 방식이다. 

전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다. 

사이드 이펙트가 없고 SUT 작업 결과는 호출자에게 반환하는 값 뿐이다. 

내부 컬렉션에서 상품을 추가하거나 데이터베이스에 저장하지 않는다. 

결과는 반환된 출력 값 뿐이다.

이러한 스타일을 함수형이라고도 한다. 

사이드 이펙트 없는 코드를 선호하는 함수형 프로그래밍에 뿌리를 두고 있다. 

# 6.1.2 상태 기반 스타일 정의

작업이 완료된 후 시스템 상태를 확인하는 스타일. 

“상태”란

- SUT의 상태
- 협력자(공유 의존성 또는 변경가능한 비공개 의존성)의 상태
- 데이터베이스, 파일 시스템(프로세스 외부 의존성)의 상태

상태 기반 테스트의 예제를 보면

출력 기반 테스트와 달리 “특정 클래스의 결과는 주문 ‘상태’의 변경”이다. 

이러한 상태를 검증한다. 

# 6.1.3 통신 기반 스타일 정의

목을 사용해 

테스트 대상 시스템과 **협력자**간의 통신을 검증한다. 

= 통신 기반 테스트는 SUT의 협력자를 목으로 대체하고 SUT가 협력자를 올바르게 호출하는지 검증한다. 

통신 기반 테스트 예시

```jsx
public void Sending_a_greetings_email()
{
var 이메일게이트웨이mock = new Mock();  → 협력자

var sut = new 컨트롤러(이메일게이트웨이.객체);

sut.유저를환영(”user@email.com”);

이메일게이트웨이.Verify(

x ⇒ x.SendGreetingsEmail(”user@email.com”),

Times.once );
}
```

<aside>
💡 단위테스트의

고전파, 런던파 모두 출력 기반 테스트를 사용하고

고전파는 상태 기반 스타일

런던파는 통신 기반 스타일을 사용한다.

</aside>

# 6.2 단위 테스트 스타일 비교

좋은 단위 테스트의 4대 요소를 토대로 비교할 수 있다

# 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다. 

회귀 방지 지표의 특성

1. 테스트 중에 실행되는 코드의 양
    1. 코드의 양과 상관없이 테스트를 작성할 수 있다. 하지만 도움이 되지 않는다. 
2. 코드 복잡도
3. 도메인 유의성
    1. 코드가 다루고 있는 데이터 , 기능, 규칙이 해당 도메인의 요구사항과 비즈니스 규칙을 정확하기 반영하고 있는지를 의미

테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다. 의존도가 낮은 단위테스트를 작성하면 테스트간의 속도는 거의 동일하다. 예외적으로 목을 사용하게 되면 지연 시간이 생길 수 있기에 목을 사용하는 통신 기반 테스트가 약간 나쁠 수는 있다.

# 6.2.2 리팩터링 내성 지표로 스타일 비교하기

리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성 수에 대한 척도다. 

거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과이다. 

1. 출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되어 

거짓 양성 방지가 가장 우수하다. 

1. 상태 기방 테스트는 테스트가 테스트 대상 메서드 이외에도 클래스의 상태와 함께 작동된다. 

즉 구현 세부사항에 테스트가 연관될 가능성이 커서 거짓 양성이 되기 쉽다. 

1. 통신 기반 테스트는 테스트 대역으로(특히 스텁) 상호 작용을 확인하는 테스트이기에 깨지기 쉽고 허위 경보에 약하다.
    1. 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다.

# 6.2.3 유지 보수 성 지표로 스타일 비교하기

유지보수성은 단위 테스트의 유지비를 측정하고 

다음 두 가지 특성으로 정의한다.

- 테스트를 이해하기 얼마나 어려운가(테스트 크기에 대한 함수)
- 테스트를 실행하기 얼마나 어려운가 (테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)

## 출력 기반 테스트의 유지보수성

출력 기반 테스트는 거의 항상 짧고 간결하다

메서드로 입력을 공급하는 것과 해당 출력을 검증하는 두 가지로 요약이 가능하기 때문에.

전역 상태나 내부 상태를 변경할 일이 없다. 프로세스 외부 의존성을 다루지 않는다. 

→ 두가지 유지 보수성 측면에서 가장 좋다.

## 상태 기반 테스트의 유지보수성

출력기반 테스트보다 더 많은 코드를 갖고 있다. (상태 데이터를 확인하고 검증하기 때문)

→ 이를 해결하기 위해 상태 기반 테스트를 단축하는 방법이 있다.

1. 헬퍼 메서드
    1. 코드를 숨기고 테스트를 단축한다.
    2. 메서드를 재사용할 때 사용된다
2. 동등 멤버 정의
    1. 검증 대상 클래스의 동등멤버를 정의할 수 있다.
    2. 클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적이다.
        1. 그게 아니라면 오직 테스트를 위해 작성한 코드로 코드베이스를 오염시키는 상황이 된다. 

## 통신 기반 테스트의 유지보수성

유지 보수성 지표에서 점수가 가장 낮다

통신 기반 테스트는 

테스트 대역, 상호 작용 검증을 설정해야하기에 코드가 길어진다. 

또한 목이 사슬형태로 있을 때 테스트는 더 커지고 유지보수하기 힘들어진다. 

# 6.2.4 결론

출력 기반 테스트가 가장 유지비가 덜 들어서 좋다.

하지만 출력 기반 스타일은 함수형으로 작성되 코드에만 적용할 수 있다. 

대부분의 객체 지향 프로그래밍 언어에는 해당하지 않는다. 

그래서 테스트를 출력 기반 스타일로 변경하는 기법이 있다.

다음은 어떻게 

상태,통신 기반테스트에서 출력 기반테스트로 바꾸는지 보여준다.

코드를 순수함수로 만들면 상태 기반 테스트나 통신기반 태스트 대신 출력 기반테스트가 가능해진다.

# 6.3.1 함수형 프로그래밍이란?

함수형 프로그래밍은 수학적 함수(순수 함수)를 사용한 프로그래밍이다. 

즉 숨은 입출력이 없는 함수(메서드)이다.

수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처에 명시해야한다. 

수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다

입출력을 명시한 수학적 함수는 

테스트가 짧고 간결하며

이해하고 유지보수하는데 쉽다.

출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다. 

이는 유지보수성이 뛰어나고 거짓 양성 빈도가 낮다.

반대로 숨은 입출력은 테스트하기 힘들게 한다. 

숨은 입출력의 유형

- 사이드 이펙트 : 메서드 시그니처에 표시되지 않은 출력으로, 클래스의 인스턴스 상태가 변경되고,파일을 업데이트하는 등이 사이드 이펙트가 발생된 경우이다.
- 예외: 메서드가 예외를 던지면 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다. 전달하지 않는 출력을 만든다.
- 내외부 상태에 대한 참조: DateTime.Now와 같이 현재 날짜와 시간을 가져오는 메서드가 있을 수 있다. 데이터베이스에서 데이터를 질의하거나 비공개 변경가능 필드를 참조할 수 있다.

프로그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환 값으로 대체할 수 있는지 확인하는 것이

메서드가 수학적 함수인지 판별하는 가장 좋은 방법이다. 

메서드 호출을 해당 값으로 바꾸는 것을 참조 투명성이라고 한다. 

내부 상태의 수정 의 예

```jsx
public 댓글추가 (string text) 
{
var 댓글 = new 댓글(text);
_댓글s.추가(댓글); <- 사이드이펙트 : 숨겨진 부분
return 댓글
}
```

# 6.3.2  함수형 아키텍처란?

함수형 프로그래밍의 목표는

비즈니스 로직을 처리하는 코드와

사이드 이펙트를 일으키는 코드를 분리하는 것이다. 

<aside>
💡 함수형 아키텍처는 사이드 이펙트를 다루는 코드를 최소화하면서 순수함수 방식으로 작성한 코드의 양을 극대화한다. 일단 객체가 생성되면 그 상태는 바꿀 수 없다.

</aside>

두 가지 코드 유형을 구분해서 둘을 분리한다. —애플리케이션에서 모든 결정을 내린다. 

- 결정 내리는 코드(함수형 코어):
    - 이 코드는 사이드 이펙트가 필요없기 때문에 수학적 함수를 사용해 작성할 수 있다.
- 해당 결정에 따라 작용하는 코드(가변 셀): —함수형 코어에 입력데이터 제공한다
    - 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.

1. 가변셀은 모든 입력을 수집
2. 함수형 코어는 결정을 생성
3. 셸은 결정을 사이드 이펙트로 변환

가변셸은 의사결정하면 안됨 함수형 코어도 결정을 잘 할 수 있도록 필요한 데이터를 제대로 입력해야함

목표는 출력 기반 테스트로 함수형 코어를 두루 다루고

가변 셸은 훨씬 더 적은 수의 통합 테스트를 맡기는 것이다.

<aside>
💡 캡슐화와 불변성
캡슐화는 코드에 모순이 생기지 않도록 보호하는 행위이다. 

불변성은 다른 각도에서 존재하는 불변을 해결한다. 이를 통해 상태 변질을 걱정할 필요가 없다. 함수형 프로그래밍에서는 캡슐화할 필요가 없으며 인스턴스를 만들때 클래스의 상태를 한 번만 확인하면 된다.

</aside>

# 6.3.3  함수형 아키텍처와 육각형 아키텍처의 비교

둘 다 관심사 분리라는 아이디어를 기반으로 한다. 

하지만 분리를 둘러싼 구체적인 내용은 다양하다.

- 공통점

1.

육각형 아키텍처는

도메인 계층: 비즈니스로직에 책임

애플리케이션 서비스 계층 : 외부 애플리케이션과의 통신에 책임

으로 구별한다. 

결정과 실행을 분리하는 함수형 아키텍처와 유사하다

1. 의존성 간의 단방향 흐름

도메인 계층 내 클래스는 서로에게만 의존해야한다. 

불변 코어는 가변셸에 의존하지 않는다. 둘을 분리할 수 있기에 셸이 제공하는 입력을 단순한 값으로 모방해 쉽게 테스트할 수 있다.

- 차이점

사이드 이펙트에 대한 처리가 다르다. 

함수형 아키텍처

모든 사이드 이펙트를 가변 셸이 처리한다.

육각형 아키텍처는

도메인 계층에 제한하는 한 도메인 계층으로 인한 사이드 이펙트도 문제 없다. 

다만 계층의 경계를 넘어서는 안된다. 

예로 도메인 클래스 인스턴스는 데이터베이스에 직접 저장할 수 없지만 상태는 변경할 수 있다. 

애플리케이션 서비스에서 이 변경사항을 데이터베이스에 적용한다.

# 6.4  함수형 아키텍처와 출력 기반 테스트로의 전환

두 가지 리팩터링 단계가 있다.

- 프로세스 외부 의존성에서 목으로 변경
- 목에서 함수형 아키텍처로 변경

예시 코드 기능

- 작업 디렉터리에서 전체 파일 목록 검색
- 인덱스별 정렬
- 감사 파일 없으면 단일 레코드로 첫번째 파일 생성
- 있으면 최신파일 가져와서 파일 항목수 한계 확인
    - 이에 따라 새 레코드 추가 또는 새파일 생성

이 기능을 하는 클래스는

파일 시스템과 연결되어 있어 그대로 테스트하기 어렵다. 

테스트 전에 파일을 확인하고 삭제해야하기 때문이다. 

병목 지점은 파일 시스템이다. 

좋은 단위 테스트의 4대 요소중 

빠른 피드백, 유지보수성이 나쁘다. 

또한 통합 테스트 범주에 속한다.

# 6.4  테스트를 파일 시스템에서 분리하기 위한 목 사용

테스트가 긴밀하게 결합된 문제는 일반적으로 파일 시스템을 목으로 처리해 해결한다. 

파일의 모든 연산을 별도 클래스로 도출하고 

AuditManager에 생성자로 해당 클래스를 주입할 수 있다. 

파일 시스팀작업하는 인터페이스 

파일 가져오기 

파일쓰기

파일 읽기

목을 사용해 더이상 파일 시스템에 접근하지 않았으므로 더 빨리 실행된다. 

빠른 피드백이 좋음으로 향상되었다. 

# 6.4.3 함수형 아키텍처로 리팩터링하기

목을 사용하지 않고 빠른 피드백과 유지보수성 지표를 향상시킬 수 있다. 

사이드이펙트를 클래스 외부로 완전히 이동시키고

AuditManager는 함수형 코어로, 파일에 수행할 작업을 둘러싼 결정만 책임지게 된다. 

새로운 클래스인 Persister는 가변셸이 되어 그 결정에 따라 파일 시스템에 업데이트를 적용한다. 

Persister가 작업디렉터리에서 파일과 해당 내용을 수집해 

AuditManager에 준다음 반환값을 파일 시스템의 변경사항으로 변환한다. 

FileUpdate 클래스는 결정을 내리기 위해 파일 시스템에 대해 알아야할 모든 것을 포함한다

직접 디렉터리의 파일을 변경하려는 대신 AuditManager는 수행하려는 사이드이펙트에 대한 명령을 반환한다
