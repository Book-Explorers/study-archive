# 5. 목과 테스트 취약성

이 장에서는 목이 취약한 테스트, 즉 리팩토링 내성이 부족한 테스트를 초래하는 것을 살펴본다.

## 목차

- 목과 스텁 구분
- 식별할 수 있는 동작과 구현 세부 사항 정의
- 리팩토링 내성 저하 없이 목 사용하기
- 리팩토링 내성 저하 없이 목 사용하기

고전파와 런던파간의 의견 차이는 테스트 격리 문제에 대한 견해에서 비롯됐다.

런던파는 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하.

고전파는 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용하여 단위 테스트를 분리해서 병렬로 실행할 수 있게 하고자 한다.

## 목과 스텁 구분

테스트 대역은 모든 가짜 의존성을 설명하는 포괄적인 용어며 사용하는 주 목적은 테스트를 편리하게 하는 것이다.

테스트 대역에는 목, 스파이, 스텁, 더미, 페이크가 존재하며 크게 목과 스텁 두 가지 유형으로 나눌 수 있다.

![스크린샷 2024-03-07 오전 11 42 16](https://github.com/rbsks/StyleLab/assets/67041069/896c0270-9a5c-4532-ada2-08f1efcbf7cc)

- 목(mock)
    - 목은 테스트 대상 시스템(SUT)과 그 협력자 사이의 상호 작용을 검사할 수 있는 테스트 대역이다.
    - **즉, 외부로 나가는 사이드 이팩트를 일으키는 상화 작용을 모방하고 검사하는데 도움된다. 사이드 이팩트 상호 작용이란 SUT가 상태를 변경하기 위해 프로세스 외부 의존성을 호출하는 것을 말한다.(애플리케이션을 통해서만 접근 가능한 외부 의존성은 제외. 예를 들면 애플리케이션에서만 접근이 가능한 데이터 베이스)**
- 스파이(spy)
    - 스파이와 목은 같은 역할을 하지만 스파이는 수동으로 생성하는 반면 목은 목 프레임워크의 도움을 받아 생성한다는 차이점이 있다.
- 스텁(stub)
    - **스텁은 내부로 들어오며 사이드 이팩트를 일으키지 않는 상호 작용을 모방하는 데 도움이된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당.**
    - 즉, 데이터베이스에서 데이터를 검색하는 것은 사이드 이팩트를 일으키지 않으며 내부로 들어오는 상호작용이다.
- 더미(dummy)
    - 더미는 null 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다.
- 페이크(fake)
    - 스텁과 페이크는 같은 역할을 하지만 페이크는 아직 존재하지 않는 의존성을 대체하고자 사용한다.

![스크린샷 2024-03-07 오전 11 46 23](https://github.com/rbsks/StyleLab/assets/67041069/6f3b32de-df75-4a62-a30d-70d75cb85800)

**도구로서의 목과 테스트 대역으로서의 목**

자바에서 자주 사용되는 Mockito는 도구로서의 목인 데 반해, Mockito로 생성한 인스턴스는 테스트 대역으로서의 목이다.

```java
public class StoreTest {

    @Test
    @DisplayName("스토어, 스토어 스태프 등록 실패 - 스토어 스태프의 중복된 이메일론 인하여 스토어와 스토어 스태프의 등록에 실패한다.")
    public void failureApplyStore_01(){
        //given
        
        // Mockito.mock은 도구로서의 mock, storeRepository는 테스트 더블로서의 mock 
        StoreRepository storeRepository = Mockito.mock(StoreRepository.class);
        given(storeRepository.save(any()))
                .willThrow(new DataIntegrityViolationException("could not execute statement [Duplicate entry 'test@gmail.com' for key 'store_staff.idx_store_staff_email']"));
        StoreService storeService = new StoreService(storeRepository);
        
        //when
        StoreException storeException = assertThrows(StoreException.class,
                () -> storeService.applyStore(store));
        
        //then
        
        /*
            storeRepository의 save() 메서드는 데이터베이스에 존재하는 store 테이블의 상태를
            변경시키기 때문에 사이드 이팩트를 일으키는 상호 작용이다. 그러므로 상호작용에 대한 검증이 필요
        */
        verify(storeRepository, times(1))
                .save(any());
        assertEquals(StoreError.STORE_AND_STORE_STAFF_SAVE_FAIL.getCode(), storeException.getServiceError().getCode());
    }
}
```

**스텁으로 상호 작용을 검증하지 말라**

목은 SUT에서 관련 의존성으로 나가는 상호 작용을 모방하고 검증하는 반면에 스텁은 내부로 들어오는 상호 작용만 모방하고 검증하지 않는다.

SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니다. 스텁을 호출하는 목적은 최종 결과를 산출하기 위한 수단일 뿐이며 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 즉, 리팩토링 내성을 저하시키는 일반적인 안티 패턴이다.

테스트에서 거짓 양성을 피하고 리팩토링 내성을 향상 시키는 방법은 구현 세부 사항에 강하게 결합된 테스트를 작성하는 것이 아니라 결과를 검증하는 테스트를 작성하는 것뿐이다.

스텁은 SUT가 최종 결과를 만들기 위해 필요한 데이터를 수집하는 방법에 대한 내부 구현 세부 사항이다. 이러한 코드 호출을 테스트 코드에서 검증하게 된다면 테스트의 취약성으로 이어질 수 있다. 다만 하나의 테스트 대역이 목과 스텁으로 둘 다 사용되는 경우에는 꼭 취약성으로 이어진다고 보장할 수 없다.

밑의 예제는 스텁이 상호 작용을 검증하는 테스트 코드이다.

```java
public class ProductTest {

    @Test
    @DisplayName("상품 상세 조회 실패 - 등록되지 않은 상품")
    public void getProductDetailFailure_01() throws Exception {
        // given
        final Long productSeq = 1L;
        doThrow(new ServiceException(ServiceError.BAD_REQUEST, "등록되지 않은 상품입니다."))
                .when(productRepository).findById(any());
        
        // when
        assertThrows(ServiceException.class, 
                () -> productService.getProductDetail(productSeq));
        
        // then
        /*
        productRepository의 findById는 사이드 이팩트를 일으키는 상호 작용이 아니다.
        이렇게 최종 결과가 아닌 사항을 검증하는 것을 과잉 명세(overspecification)라고 부른다.
        */
        verify(productRepository, times(1))
                .findById(any());
    }
}
```

**목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?**

목과 스텁의 개념은 명령 조회 분리(CQS: Command Query Separation)원칙과 관련이 있다.

CQS원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며,  이 둘을 혼용해서는 안된다.

- 명령(Command)
    - 명령은 사이드 이팩트를 일으키고 어떤 값도 반환하지 않는(void) 메서드다. 하지만 항상 값을 반환 하지 않는 것은 아니다. JPA의 save() 메서드와 stack의 pop() 메서드는 사이드 이팩트를 일으키는 명령 메서드지만 반환 값이 존재한다.
    - 명령을 대체하는 테스트 대역은 목이다.
- 조회(Query)
    - 조회는 사이드 이팩트가 없고 결과를 반환하는 메서드다. 즉, 조회를 할 때 마다 조회 결과가 달라져서는 안된다. 멱등성이 보장돼야 한다는 의미와 같다.
    - 조회를 대체하는 테스트 대역은 스텁이다.

![스크린샷 2024-03-07 오후 2 13 37](https://github.com/arffy-online/admin/assets/67041069/9b2334d9-9816-4128-8a9b-1b1621a5698e)

## 식별할 수 있는 동작과 구현 세부 사항

테스트의 취약성은 좋은 단위 테스트의 두 번째 특성인 리팩토링 내성에 해당하며 리팩토링 내성 지표가 있는지 여부는 대부분 이진 선택이므로(리팩토링 내성이 아예 있거나 아예 없거나) 리팩토링 내성 지표가 가장 중요하다.

테스트에 거짓 양성이 존재하여 리팩토링 내성이 저하되는 주요 이유는 테스트가 코드 베이스의 내부 구현 세부 사항에 강하게 결합되어 있기 때문이다. 이러한 강한 결합을 피하는 방법은 SUT가 반환하는 최종 결과를 검증하여 내부 구현 세부 사항과 테스트를 격리시는 것뿐이라고 위에서도 설명했다. 즉, 어떻게 테스트 할 것이냐 가 아니라 무엇을 테스트할 것이냐에 중점을 둬야한다.

**식별할 수 있는 동작은 공개 API와 다르다**

모든 제품 코드는 public, private 키워드를 사용한 공개 API 또는 비공개 API와 식별할 수 있는 동작 또는 구현 세부 사항 이렇게 두 가지로 분류할 수 있다.

코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 만족해야 하며, 구현 세부 사항은 이 두 가지 중 아무것도 하지 않는다.

- 클라이언트가 목표를 달성하는 데 도움되는 연산(operation)을 노출해야 한다. 연산은 계산을 수행하거나 사이드 이팩트를 일으키거나 둘 다 하는 메서드다.
- 클라이언트가 목표를 달성하는 데 도움되는 상태(state)를 노출해야 한다. 상태는 시스템의 현재 상태다.

❗️객체는 상태(state)와 이 상태를 변경하고 조회하기 위한 행위(method)를 가진다.

코드가 식별할 수 있는 동작인지 여부는 해당 클라이언트가 누구인지, 목표가 무엇인지에 달려있다.

식별할 수 있는 동작이 되려면 코드가 이러한 목표 중 하나라도 직접적인 관계가 있어야 한다. 잘 설계된 API는 식별할 수 있는 동작(클라이언트의 목표)과 일치해야하며, 모든 구현 세부 사항은 클라이언트에게 노출해서는 안된다.

**구현 세부 사항 유출의 예**

**연산의 예**

상태(속성)과 메서드 전부를 공개하는 API는 구현 세부 사항을 유출하게 된다.

클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움되는 유용한 규칙이 있다. 클라이언트가 단일 목표를 달성하고자 호출해야 하는 연산(메서드)의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 노출하고 있을 가능성이 크다. 3장에서 실행 구절이 두 줄 이상인 경우를 경계하라는 내용과 비슷한 맥락이다.

**잘 설계된 API와 캡슐화**

잘 설계된 API를 유지 보수하는 것은 캡슐화 개념과 관련있다. 캡슐화는 불변성 위반(변해야 할 것이 변하지 않는 것)이라고도 하는 모순을 방지하는 조치다. 불변성은 항상 참이어야 하는 조건이다. 예를 들자면 사용자 이름이 50자를 초과하면 안 된다는 불변성이 있다.

불변성 위반으로 구현 세부 사항이 노출되면 클라이언트에서 불변성을 지키기 위한 연산을 직접 호출해야 하기 때문에 즉, 실행 구절이 두 줄 이상이 되기 때문에 자칫하여 실행 구절을 실수로 호출하지 않는 다면 불변성을 위반할 수 있게 된다.

프로젝트가 후반 부로 갈 수록 코드베이스가 점점 복잡해질 가능성이 높고 그렇기 때문에 작업하기가 더 어려워지고 개발 속도가 느려지게 되며 버그 수가 증가하게 된다. 이렇게 계속해서 증가하는 코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고는 없다.

캡슐화를 하지 않은 API(클래스)는 해당 API로 할 수 있는 것과 할 수 없는 것을 명확하게 알려주지 않기 때문에 코드 변경 시 버그가 발생하지 않도록 많은 것을 염두하면서 작업해야한다. 그렇기 때문에 캡슐화를 통해 구현 세부 사항을 숨기고 클라이언트의 목표를 달성하기 위해 필요한 상태와 연산만 제공해야 한다. 또한 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다. 이러한 캡슐화를 통해 구현 세부 사항을 단위 테스트와 동일한 목표인 지속적으로 성장할 수 있는 프로젝트를 만들 수 있게 된다.

**상태의 예**

별 거 없기 때문에 생략

구현 세부 사항을 노출하고 식별할 수 있는 동작을 숨기게 되면 클라이언트가 목표를 달성하기 위한 과정이 너무 복잡해 지고 불변성 위반을 초래하기 때문에 캡슐화를 통해 연산과 상태를 최소한으로 노출하여 클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개하며 구현 세부 사항은 비공개로 숨겨야 한다.

모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없으며, 이로 인해 리팩토링 내성도 자동으로 좋아진다. 즉, API를 잘 설계하면 단위 테스트도 자동으로 좋아진다는 의미다.

아래는 위에서 얘기한 내용을 간략하게 정리한 표다.

|  | 식별할 수 있는 동작 | 구현 세부 사항 |
| --- | --- | --- |
| 공개 | 좋음 | 나쁨 |
| 비공개 | 해당 없음 | 좋음 |

## 목과 테스트 취약성 간의 관계

**헥사고날 아키텍처 정의**

![스크린샷 2024-03-07 오후 10 11 29](https://github.com/arffy-online/admin/assets/67041069/6a2519c2-a509-408d-993f-ca4428f4f0b7)

전형적인 애플리케이션은 그림과 같이 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다.

도메인 계층은 어플리케이션 중심부이기 때문에 중앙에 위치하고 애플리케이션의 필수 기능으로 비즈니스 로직이 포함돼 있다.

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과 통신을 조정한다.

예를 들어 RESTful API인 경우 API에 대한 모든 요청이 먼저 애플리케이션 서비스 계층에 도달한다. 이 계층은 도메인 클래스와 프로세스 외부 의존성 간의 작업을 조정한다.

애플리케이션 서비스에 대한 조정 예시

- 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
- 구체화된 인스턴스에 연산 호출
- 결과를 데이터베이스에 저장

헥사고날 아키텍처의 세 가지 중요 지침

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
    - 도메인 계층은 해당 비즈니스 로직에 대해서만 책임을 가져야하며, 애플리케이션의 도메인 지식의 모음으로 사용해야 한다.
    - 애플리케이션 서비스 계층은 외부 애플리케이션과 통신하거나 데이터베이스에서 데이터를 검색하는 것과 같은 책임을 가져야하며, 어떠한 비즈니스 로직이 있어서는 안 된다. 애플리케이션 서비스 계층은 일련의 유즈케이스(사용 대상)로 볼 수 있다.
- 애플리케이션 내부 통신
    - 헥사고날 아키텍처에서는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다.
    - 도메인 계층은 내부 클래스 끼리 서로 의존하고 애플리케이션 서비스 계층에 의존하지 않는다.
    - 애플리케이션 서비스 계층은 도메인 계층을 알지만 반대로 도메인 계층은 외부 환경에서 완전히 격리돼야 한다.
- 애플리케이션 간의 통신
    - 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션과 연결된다. 애플리케이션 서비스 계층과 연결되지 않고 그 누구도 도메인 계층에 접근해서도 안 되며 하게끔 해서도 안 된다.

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함하고 있다. 도메인 계층의 식별할 수 있는 동작은 연산과 상태이고 이 둘을 통해 애플리케이션 서비스 계층이 적어도 하나의 목표를 달성하는 데 도움이 된다.

아래 사진은 각 계층이 어떻게 테스트해야하는지 보여주고 있다.

애플리케이션 서비스 계층은 전반적으로 비즈니스 유즈케이스가 어떻게 실행되는지 확인한다.

도메인 계층은 유스케이스 완료 방법에 대한 중간의 하위 목표를 검증한다.

![스크린샷 2024-03-07 오후 10 35 58](https://github.com/arffy-online/admin/assets/67041069/7e239263-beb5-4211-914a-d46b0b0155f7)

식별할 수 있는 동작은 바깥 계층(애플리케이션 서비스 계층)에서 안쪽(도메인 계층)으로 흐른다.

외부 클라이언트가 달성하려는 목표는 개별 도메인 클래스가 달성하는 하위 목표로 변환된다.

이렇게 가장 안쪽 계층에서 애플리케이션 서비스 계층 바깥쪽으로, 그리고 외부 클라이언트의 요구 사항까지 재귀적으로 거슬러 올라갈 수 있어야 한다.

도메인 계층의 경우 클라이언트는 애플리케이션 서비스 계층이다.

애플리케이션 서비스 계층의 클라이언트는 외부 클라이언트다.

**시스템 내부 통신과 시스템 간 통신**

일반적인 애플리케이션에는 시스템 내부(inter-system) 통신과 시스템 간(intra-system) 통신이 있다.

- 시스템 내부 통신
    - 애플리케이션 내 클래스 간 통신이며 구현 세부 사항이다.
- 시스템 간 통신
    - 애플리케이션이 다른 애플리케이션과 통신하는 것.

![스크린샷 2024-03-07 오후 11 23 01](https://github.com/arffy-online/admin/assets/67041069/b975737f-2a4d-4972-8620-a7b5746decf3)

연산(클라이언트의 목표)을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 구현 세부 사항에 해당하며 시스템 내부 통신이다. 이러한 협력은 클라이언트의 목표와 직접적인 관계가 없다. 따라서 이러한 협력과 결합된 테스트 코드를 작성하면 취약해진다. 이와 달리 시스템 간 통신은 전체적으로 식별할 수 있는 동작을 나타낸다

시스템 간 통신의 특성은 별도 애플리케이션과 하위 호환성을 지키며 함께 성장하는 방식에서 비롯된다. 시스템 내부에서 하는 리팩토링과 다르게, 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야한다. 외부 애플리케이션을 호출할 때 매개변수의 유형과 개수를 맞춰주는 것을 예로 들 수 있다.

목을 사용하면 시스템(애플리케이션)과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다. 반대로 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 리팩토링 내성이 저하된다.

**시스템 내부 통신과 시스템 간 통신의 예**

다음 비즈니스 유스케이스를 통해 시스템 내부 통신과 시스템 간 통신의 차이점을 설명하겠다.

- 고객(Customer)이 상점(Store)에서 제품을 구매하려고 한다.
- 매장 내 제품 수량이 충분하면
    - 재고가 상점에서 줄어든다.
    - 고객에게 이메일로 영수증을 발송한다.
    - 확인 내역을 반환한다.

```java
public class CustomerService {

    private final CustomerRepository customerRepository;
    private final ProductRepository productRepository;
    private final StoreRepository storeRepository;
    private final EmailGateWay emailGateWay;
    
    public CustomerController(
    CustomerRepository customerRepository, 
    ProductRepository productRepository,
    StoreRepository storeRepository,
    EmailGateWay emailGateWay) {
        this.customerRepository = customerRepository;
        this.productRepository = productRepository;
        this.storeRepository = storeRepository;
        this.emailGateWay = emailGateWay;
    }
    
    public bool purchase(Integer customerId, Integer productId, Integer storeId, Integer quantity) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> CustomerException("고객을 찾을 수 없습니다."));
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> ProductException("상품을 찾을 수 없습니다."));
        Store store = storeRepository.findById(storeId)
                .orElseThrow(() -> StoreException("상점을 찾을 수 없습니다."));
        
        bool isSuccess = customer.purchase(store, product, quantity);
        if(isSuccess) {
            emailGateWay.sendReceipt(customer.email, product.name, quantity);
        }
        
        return isSuccess;
    }
}
```

CustomerService의 purchase 메서드는 시스템 내부 통신과 시스템 간 통신 모두 있는 비즈니스 유즈케이스다.

Customer, Store, Product 도메인 클래스 간 통신은 시스템 내부 통신이며 고객은 상점에 재고가 층분한지 확인하고, 충분하면 제품 수량을 감소시킨다. 마지막으로 이메일 게이트웨이를 통해 고객에게 이메일로 영수증을 발급하는 부분과 isSuccess의 결과를 받는 외부 클라이언트는 애플리케이션 서비스 외부에 존재하므로 시스템 간 통신이다.

SMTP 서비스에 대한 호출을 목으로 하는 이유는 타당하다. 리팩토링 후에도 이러한 통신 유형이 그대로 유지되도록 하기 때문에 취약성을 야기하지 않는다. 하지만 Customer, Product, Store 도메인 클래스 간 통신(메서드 호출)은 애플리케이션 경계를 넘지 않고 구현 세부 사항이기 때문에 목을 사용하여 호출을 검증하면 취약성을 야기할 수 있다.

## 단위 테스트의 고전파와 런던파 재검토

단위 테스트의 고전파와 런던파 간 차이점을 정리한 간략한 표를 보자.

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단위 클래스 | 불변 의존성를 제외한 모든 의존성 |
| 고전파 | 단위 테스트 | 단위 클래스 또는 클래스 세트 | 공유 의존성 |

런던파는 불변 의존성을 제외한 모든 의존성에 목을 권장하며 시스템 내부 통신과 시스템 간 통신을 구분하지 않는다. 즉, 시스템 내부 통신과 시스템 간 통신 전부 호출에 대한 검증을 한다는 의미다. 이렇게 목을 무분별하게 사용하면 테스트 코드가 코드 베이스 내부 구현 세부 사항과 강하게 결합되어 테스트의 리팩토링 내성이 저하된다.

고전파는 테스트 간에 공유 의존성(SMTP 등 프로세스 외부 의존성)만 목을 사용하기 때문에 리팩토링 내성에서 런던파보다 훨씬 유리하다.

**모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다**

프로세스 외부 의존성과 목을 설명하기 전에 의존성 유형에 대해서 살펴보겠다.

- 공유 의존성: 테스트 간에 공유하는 의존성
- 프로세스 외부 의존성: 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성(DB, 메세지 버스, SMTP 서비스 등)
- 비공개 의존성: 공유하지 않는 모든 의존성

고전파에서는 공유 의존성을 피할 것을 권고하는데 그 이유는 테스트가 서로의 실행 컨텍스트를 서로 방해하여 테스트가 병렬로 실행되는 것을 방해하기 때문이다. 테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것을 테스트 격리라고 부른다.

공유 의존성이 같은 프로세스에 존재하면 해당 의존성을 각 테스트에서 새로운 인스턴스로 써서 테스트 끼리 공유 의존성을 재사용하지 않도록 할 수 있지만 공유 의존성이 프로세스 외부에 있는 경우 위와 같은 방법을 사용하면 테스트 속도가 현저히 느려지기 때문에 테스트 대역 즉, 목과 스텁으로 교체해서 테스트한다.

그러나 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다. 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있으면, 이러한 의존성과의 통신은 외부 시스템에서 식별할 수 있는 동작이 아니다.

대부분의 애플리케이션과 외부 시스템은 동시에 변경할 수 없거나 배포 주기가  다르고 제어 권한이 없을 수 있기 때문에 시스템 간의 하위 호환성을 지켜 통신 패턴을 항상 지켜야 하는 요구 사항이 존재한다.

그러나 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면, 하위 호환성 요구 사항은 사진다. 이러한 통신 패턴은 애플리케이션내의 구현 세부 사항이 된다.

대표적인 예로 애플리케이션에서만 접근이 가능한 데이터베이스가 있다. 대부분의 데이터베이스는 외부 시스템에서 직접 접근하지 못하고 애플리케이션에 요청을 보내 간접적으로 접근하게 된다. 이렇게 애플리케이션이 통제권을 가진 프로세스 외부 의존성을 목을 사용하면 깨지기 쉬운 테스트로 이어질 수 있다. 난 항상 데이터베이스의 호출은 테스트 도구인 Mockito를 사용하여 하나의 테스트 대역을 목과 스텁으로 사용하여 단위 테스트를 했는데 이 방법은 틀린거란다… 6, 7장에 설명해준다네…

목은 애플리케이션 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 사이드 이펙트가 외부 환경에서 보일 때만 동작을 검증해야 한다. 즉, 외부 시스템에 요청을 보내는 경우 이 요청으로 인해 외부 시스템의 상태가 변경되어 외부 환경에 영향을 주는 경우에만 목을 통한 호출 검증을 해야한다.

![스크린샷 2024-03-08 오전 10 07 43](https://github.com/arffy-online/admin/assets/67041069/a059f099-b238-4ebe-8557-2a6b8a12760f)
