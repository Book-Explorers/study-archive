# 4. 좋은 단위 테스트의 4대 요소

### 목표

- 좋은 단위 테스트의 관점 간 차이점 모색
- 이상적인 테스트 정의
- 테스트 피라미드 이해
- 블랙박스 테스트 및 화이트박스 테스트 사용

### 좋은 단위 테스트 스위트의 특성

- 실제로 사용되는 테스트가 개발 주기에 통화돼 있다.
- 애플리케이션의 핵심(도메인 모델)을 다른 것과 구별하여 코드베이스의 가장 중요한 부분만 대상으로 테스트를 작성한다.
- 낮은 가치의 테스트를 식별하여 가치 있는 테스트를 작성하고 최소한의 유지비로 최대 가치를 끌어낸다.

### 좋은 단위 테스트의 4대 요소

1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

**1. 회귀 방지**

코드를 수정한 후 기능이 의도한 대로 동작하지 않는 경우를 회귀라 한다. 회귀 방지 지표를 판단 할 수 있는 사항은 다음과 같습니다.

- 테스트 중에 실행되는 코드의 양
    - 일반적으로 실행되는 코드의 양이 많을수록 테스트에서 회귀가 나타날 가능성이 높다. 코드가 예외를 발생시키지 않고 실행된다는 것을 아는데서 끝나는 것이 아니라 테스트의 결과가 유효한지도 확인해 봐야 한다.
- 코드 복잡도
- 코드의 도메인 유의성
    - 코드의 도메인 유의성이란 코드가 다루는 데이터, 기능, 규칙이 해당 도메인(문제 영역 또는 비즈니스 도메인)의 요구 사항과 비즈니스 규칙을 정확하게 반영하고 있는지를 의미. 즉, 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 때문에 코드의 도메인 유의성을 높여야 함.
- 낮은 가치의 테스트
    - 단순한 코드를 테스트하는 것은 가치가 거의 없다. 이러한 코드는 짧고 비즈니스 로직을 많이 담고 있지 않으며 실수할 여지가 많지 않기 때문에 회귀 오류가 많이 생기지 않는다. 이 부분을 방지하기 위해 테스트가 해당하는 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 의존성에 대해 검증이 올바른지도 확인 해야 한다.

회귀 방지 지표를 극대화하려면 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야 한다.

**2. 리팩토링 내성**

기존 테스트 코드를 실패로 만들지 않고 기존 코드를 리팩토링할 수 있는지에 대한 척도다.

❗️리팩토링이란 동작을 수정하지 않고 기존 코드를 변경하여 가독성을 높이고 복잡도를 낮추는 것. 예를 들면 의미있는 메서드 이름으로 바꾸거나 코드 조각을 새로운 클래스나 메서드로 추출하는 것이다.

단위 테스트의 목표는 테스트를 작성함으로서 회귀 없이 리팩터링하고 새로운 기능을 추가할 수 있게하여 프로젝트가 지속적으로 성장 가능하게 끔 하는 것이다. 이 목표로 인해 얻을 수 있는 두 가지 장점이 존재한다.

1. 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 조기 경고 덕분에 결함이 있는 코드가 운영 환경에 배포되기 훨씬 전에 문제를 해결할 수 있다. 즉, 사이드 이팩트를 사전에 발견해 조치할 수 있다.
2. 코드 변경이 회귀로 이어지지 않을 것이라는 확신하게 된다.

**거짓 양상(허위 경보)**

리팩토링 후 기능이 의도한 대로 동작하고 결과가 바뀌지 않았는데 테스트가 실패하는 현상을 거짓 양상(허위 경보)이라 한다. 거짓 양성은 위에서 설명한 단위 테스트의 목표로 얻을 수 있는 두 가지 장점을 모두 방해한다.

1. 테스트가 타당한 이유 없이 실패하면 타당한 이유로 인한 실패도 무시하기 시작해 기능이 고장나도 운영 환경에 그대로 배포될 수 있다. 양치기 소년…
2. 거짓 양성(허위 경보)가 빈번하면 테스트 스위트에 대한 신뢰도가 떨어지며, 더 이상 믿을만한 안전망으로 인식하지 않는다. 회귀를 피하기 위해 코드 변경을 하지 않아 리팩터링이 점점 줄어들게 된다.

**무엇이 거짓 양성의 원인인가?**

테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항과 많이 결합될 수록 거짓 양성이 더 많이 생긴다. 즉, 테스트와 SUT의 구현 세부 사항과 결합될 수록 최종 결과가 바뀌지 않을지라도 테스트가 실패할 가능성이 높아진다. 이러한 테스트는 잘못된 경고로 인해 회귀 방지가 불가능하며 리팩터링 내성이 없다고 볼 수 있다.

**구현 세부 사항 대신 최종 결과를 목표로 하기**

거짓 양성이 생길 수 있는 방법을 줄이는 방법은 테스트와 SUT의 구현 세부 사항과 분리를 하여(결합도를 낮추어) 테스트가 SUT의 구현 코드를 검증하는 것이 아니라 SUT가 제공하는 최종 결과를 검증하게 해야한다.

이렇게 내부 구현 코드를 검증하지 않고 최종 결과로 동작을 검증하는 방식을 블랙박스 테스트라한다.

이러한 테스트는 결과를 검증하기 때문에 애플리케이션 동작의 변경을 알려주므로 사전에 회귀 방지를 할 수 있고 리팩터링으로 인해 테스트가 실패하지 않기 때문에 거짓 양성이 거의 없다 볼 수 있다. 거짓 양성이 거의 없다 말한 이유는 MUT의 파라미터가 바뀐 경우 컴파일 에러가 발생할 수 있는데 이러한 부분도 거짓 양성으로 보기 때문이다. 하지만 이러한 거짓 양성은 해결하기 쉽다. 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다.

### 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

회귀 방지와 리팩토링 내성은 정반대 관점에서 테스트 스위트 정확도에 기여한다.
프로젝트가 시작된 직후에는 회귀 방지를 갖추어야 하지만 리팩토링 내성은 그렇지 않다.

**테스트 정확도 극대화**

코드의 정확도와 테스트 결과에 따른 표와 같은 네 가지 결과가 있을 수 있다.
위에서 언급한 회귀 방지와 리팩토링 내성은 테스트 스위트의 정확도를 극대화하는 것이 목표다.

![스크린샷 2024-02-29 오전 7 53 14](https://github.com/rbsks/StyleLab/assets/67041069/7d40ce36-31b0-4292-bccc-ca51996bf84e)

**올바른 추론(참 음성)**

테스트가 통과하고 기본 기능이 의도한 대로 잘 동작하는 상황

테스트는 시스템의 상태를 버그 없이 올바르게 유추했기 때문에 작동 기능과 통과 테스트의 조합에 대한 용어로 참 음성이라고 한다.

**올바른 추론(참 양성)**

기능이 제대로 동작하지 않아 테스트가 실패할 것으로 예상했기 때문에 올바른 추론이다. 이 부분이 단위 테스트의 핵심이며 참 양성이라고 한다.

**2종 오류(거짓 음성) - 회귀 방지와 관련**

기능이 고장 났지만 테스트가 통과하는 경우.

**1종 오류(거짓 양성) - 리팩토링 내성과 관련**

기능이 의도한 대로 동작하지만 테스트가 실패하는 경우.

테스트 정확도 = signal(발견된 버그 수) / noise(허위 경보 발생 수)

테스트 정확도를 향상 시키기 위해 두 가지 방법이 존재한다.

1. 발견된 버그 수를 증가시키는 것. 즉, 회귀를 더 많이 찾아내는 코드로 개선하는 것
2. 허위 경보 발생 수 를 줄이는 것. 즉, 리팩토링 내성을 갖는 코드로 개선하는 것

**1, 2종 오류는 구현 코드 세부 사항에 강하게 결합된 테스트 코드에서 많이 나타날 수 있다. 이 부분을 최소화 시키기 위해서는 구현 코드를 검증하는 것이 아니라 결과를 검증해야한다**

**거짓 양성과 거짓 음성의 중요성: 역학 관계**

프로젝트 초기에는 거짓 양성(리팩토링 내성)은 테스트 스위트에 부정적인 영향을 많이 미치지 않아 거짓 음성(회귀 방지)에 중점을 두게 되는데 프로젝트가 성장함에 따라 점점 큰 영향을 미치기 시작한다.

그 이유는 리팩토링은 프로젝트 초기보다 후반부에 많이 이루어지기 때문이다. 후반부로 갈 수록 기존 요구사항이 변경됨에 따라 기존 코드베이스가 수정이 되면서 코드베이스는 점점 나빠지게 되는데 이때 리팩토링 내성이 점점 중요해지기 시작한다. 이때 테스트 코드가 구현 코드 세부 사항에 강하게 결합되어 있으면 결과는 달라지지 않았음에 불구하고 테스트가 실패하기 때문에 테스트에 대한 신뢰도가 점점 떨어지게 된다.

### 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

**빠른 피드백**

빠른 피드백은 단위 테스트의 필수 속성이다. 테스트 수행 속도가 빠를 수록 더 자주 더 많이 테스트를 실행할 수 있고 이로인해 빠른 피드백도 챙길 수 있다. 반면에 수행 속도가 느린 테스트는 자주 실행하지 않게 되기 때문에 잠재적인 버그가 많이 생길 수 있다.

**유지 보수성**

유지비를 평가하는 유지 보수성 지표는 두 가지 주요 요소로 구성된다.

- 테스트가 얼마나 이해하기 어려운가
  - 이 구성 요소는 테스트의 크기와 관련있다. 단지 라인 수를 줄이려고 테스트 코드를 인위적으로 압축하는 경우를 제외하고 테스트 코드 라인이 적을 수록 더 읽기 쉽고 이러한 테스트 코드는 변경하는 것도 쉽다. 테스트 코드의 품질은 코드 베이스만큼 중요하다. 절차를 생략하지 말고 테스트 코드를 **일급 시민(first-class citizen)**으로 취급해야한다.
- 테스트가 얼마나 실행하기 어려운가
  - 테스트 코드에 외부 종속성으로 작동하는 부분이 많으면 그렇지 않은 테스트 코드에 비해 수행속도도 느릴 뿐더러 실행하기 까다롭다.

### 이상적인 테스트를 찾아서

좋은 단위 테스트의 4대 특성인 회귀 방지, 리팩토링 내성, 빠른 피드백, 유지 보수성의 가치(0~1)을 곱하면 테스트의 가치가 결정된다. 네 가지 특성 중 하나라도 0의 가치를 갖는다면 테스트의 가치는 0이 되며 이러한 테스트는 제거 대상이다.

테스트 코드를 포함한 모든 코드는 책임을 가지며, 테스트에 대한 최소 가치를 설정하고 이 가치를 충족하는 테스트 코드만 남겨야 프로젝트가 계속 성장하는데 도움이 될 수 있다.

**이상적인 테스트를 만들 수 있는가?**

이상적인 테스트는 네 가지 특성 모두 가치가 1이다. 하지만 이러한 테스트를 만드드는 것은 불가능하다.

회귀 방지, 리팩토링 내성, 빠른 피드백은 상호 배타적이기 때문이다. 세 가지 특성 중 한 가지 특성을 희생해야 나머지 두 가지 특성을 최대화 시킬 수 있다. 이상적인 테스트를 보기 전에 극단적인 테스트 사례 부터 살펴보겠다.

**극단적인 사례 1: 엔드 투 엔드 테스트**

엔드 투 엔드 테스트는 데이터베이스, 외부 API를 포함한 많은 코드를 최종 사용자 관점에서 기능이 어떻게 동작하는 테스트하므로 회귀 방지를 훌륭하게 해낸다. 또한 리팩토링을 올바르게 했다면 기존 결과가 변하지 않으므로 리팩토링 내성이 좋다. 그러나 실행 속도가 느려 빠른 피드백을 받을 수 없다는 단점이 있다.

**극단적인 사례 2: 간단한 테스트**

간단한 코드를 다루는 간단한 테스트는 매우 빠르게 실행되어 빠른 피드백을 받을 수 있고 코드가 간단하기 때문에 리팩토링 내성이 우수하다. 하지만 코드가 너무 단순해서 회귀가 일어날 가능성이 낮을 것이다. 심지어 간단한 테스트는 이름만 바꿀 뿐 동어 반복 테스트(tautology test)를 불러오기 때문에 테스트가 항상 통과하여 검증이 무의미해질 수 있다.

**극단적인 사례 3: 깨지기 쉬운 테스트**

빠른 피드백과 회귀 방지에 대한 수치가 높지만 리팩토링 내성 수치가 낮은 테스트를 깨지기 쉬운 테스트라 한다.

이러한 테스트 코드는 리팩토링을 견디지 못하고 기능이 고장 났는지 여부와 관계없이 테스트가 실패로 바뀔 가능성이 높다. 위에서도 언급이 자주 됐던 결과를 검증하는 것이 아니라 구현 세부 사항에 강하게 결합된 테스트 코드가 이에 해당한다.

**이상적인 테스트를 찾아서: 결론**

좋은 단위 테스트의 특성 중 회귀 방지, 리팩토링 내성, 빠른 피드백은 상호 배타적이다. 즉, 세 가지 특성 중 한 가지 특성의 가치를 희생해야한다. 네 번째 특성인 유지 보수성은 의존성 관리에 대한 노력이 필요한 엔드 투 엔드 테스트를 제외하고 위 세 가지 특성과는 상관관계가가 없다.

유지 보수성을 제외한 나머지 특성은 상호 배타성을 가진다고 했다. 통합 테스트와 엔드 투 엔드 테스트만 사용하지 않는 이상 리팩토링 내성을 최대한 많이 갖는 것을 목표로 하는 것이 좋다. 따라서 회귀 방지와 빠른 피드백 사이의 적절한 선택으로 좋은 테스트를 만들도록 노력해야한다.

### 대중적인 테스트 자동화 개념 살펴보기

**테스트 피라미드 분해**

테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비융을 일컫는 개념이다.

![스크린샷 2024-03-01 오후 1 26 41](https://github.com/rbsks/StyleLab/assets/67041069/a7ae434c-5bf6-4841-97b3-8d170c45bdb9)

피라미드의 각 층의 너비는 테스트 스위트에서 해당 테스트의 비율을 나타낸다. 즉, 넓을 수록 테스트 수는 많아진다. 층의 높이는 테스트가 최종 사용자의 관점에서 테스트를 실행하느냐의 척도이다. 마지막으로 프로젝트의 테스트 유형간 비율은 피라미드 형태로 가져가는 것이 좋다.

피라미드 내의 테스트 유형에 따라 회귀 방지와 빠른 피드백 중 어느 특성에 가치를 높일지 선택한다.

어느 계층도 리팩토링 내성을 포기하지 않으며, 모든 테스트는 거짓 양성을 가능한 적게 하는 것을 목표로 해야한다.

![스크린샷 2024-03-01 오후 1 22 20](https://github.com/rbsks/StyleLab/assets/67041069/e37fe918-b11c-4ab4-9300-993e45487d7b)

**블랙박스 테스트와 화이트박스 테스트 간의 선택**

- 블랙박스 테스트: 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다. 즉, 구현 세부 사항을 검증하는 것이 아니라 결과에 대해서 검증하는 테스트 방법.
- 화이트박스 테스트: 시스템의 내부 구조를 검사하는 소프트웨어 테스트 방법이다. 즉, 구현 세부 사항을 검증하는 테스트 방법.

|  | 회귀 방지 | 리팩토링 내성 |
| --- | --- | --- |
| 화이트박스 테스트 | 좋음 | 나쁨 |
| 블랙박스 테스트 | 나쁨 | 좋음 |

화이트박스 테스트는 명세와 요구사항(결과)에만 테스트하는 블랙박스에서 놓칠 수 있는 많은 오류를 발견할 수 있는 장점이 존재하지만 구현 세부 사항과 강하게 결합되어 있기 때문에 결과가 바뀌지 않더라도 리팩토링 후 테스트가 실패할 수 있는 가능성이 높아진다. 즉, 리팩토링 내성이 부족하기 때문에 거짓 양성이 많아진다.

위에서 언급한 것 처럼 리팩토링 내성은 포기할 수 없다. 그렇기 때문에 기본적으로 모든 테스트는 블랙박스 테스트방법을 사용하고 테스트 분석 시 화이트박스 테스트를 사용해야한다.
