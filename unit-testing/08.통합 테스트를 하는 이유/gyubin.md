# 8. 통합 테스트를 하는 이유

## 8장에서 다루는 내용

- 통합 테스트의 역할 이해
- 테스트 피라미드의 개념 자세히 살펴보기
- 가치 있는 통합 테스트 작성

단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다. 단위 테스트가 비즈니스 로직을 확인하는 데 좋지만, 비즈니스 로직을 외부와 단절된 상태로 확인하는 것만으로는 충분하지 않다. 각 부분이 데이터베이스나 메시지 버스 등의 외부 시스템과 어떻게 통합되는지 확인하는 것이 중요하다.

## 통합 테스트는 무엇인가?

### 통합 테스트의 역할

단위 테스트는 단일 동작 단위(작은 코드)를 검증하고, 빠르게 수행되어야 하며, 격리(고립)된 환경에서 실행되어야 한다는 세 가지 요구 사항을 충족하는 테스트다. 이 세 가지 요구 사항 중 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속한다.

통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드가 어떻게 작동하는지를 검증한다. 즉, 컨트롤러 사분면에 속하는 코드를 검증한다.

### 다시 보는 테스트 피라미드

이러한 테스트는 테스트의 수행 속도가 느려지며 유지비가 많이 든다. 하지만 애플리케이션 코드와 더불어 사용하는 라이브러리 코드 포함한 더 많은 코드를 거치므로 회귀 방지가 단위 테스트보다 우수하다. 또한 코드 베이스와의 결합도가 낮아 리팩토링 내성도 우수하다.

단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 단위 테스트로 가능한 많은 비즈니스 시나리오의 예외 상황을 확인하고, 통합 테스트로 주요 흐름(happy path)과 단위 테스트가 다루지 못하는 기타 예외 상황(edge case)을 다루게 끔 구성하는 것이 좋다.

❗️happy case는 시나리오의 성공적인 실행이다. edge case는 시나리오 수행 중 오류가 발생하는 경우다.

단위 테스트로 가능한 많은 비즈니스 로직을 검증하면 유지비를 절감할 수 있다. 또한 비즈니스 시나리오당 한 두개의 통합 테스트로 다른 서브 시스템(프로세스 외부 의존성)과 통합해 코드를 검증하게 되면 시스템 전체의 정확도를 보장할 수 있다.

![스크린샷 2024-03-28 오후 11 20 09](https://github.com/rbsks/StyleLab/assets/67041069/bd57ea01-a2ff-48c1-8799-e4e21df8d5b8)

### 통합 테스트와 빠른 실패

통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 happy path를 선택해야 한다. 그렇기 때문에 통합 테스트를 작성 및 수행하는 시간이 단위 테스트에 비해 많이 든다. 통합 테스트의 충분한 가치를 가져다주지 못하는 상황이 있다. 예를 들자면 어떠한 예외 상황에 잘못 실행돼 전체 애플리케이션이 즉시 실패하는 즉, 버그를 빨리 나타나게 하는 Fast Fail Principle을 적용한 코드다. 이런 상황에 대한 테스트는 도메인 모델에 전제 조건이 있는지 파악 후 단위 테스트로 대체하는 것이 더 바람직하다.

**빠른 실패 원칙**

빠른 실패 원칙은 예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미한다. 이 원칙은 다음을 통해 애플리케이션의 안정성을 높인다. 보통 예외를 던져서 현재 연산을 중단한다. 이러한 로직은 애플리케이션 시작 부근에 둬서 문제가 있으면 불필요한 연산을 하지 않도록 할 수 있다.

- 피드백 루프 단축
    - 버그를 빨리 발견할수록 문제를 더 쉽게 해결할 수 있다. 이미 운영 환경에 적용된 버그는 개발 중에 발견된 버그보다 수정 비용이 훨씬 크다.
- 지속성 상태 보호
    - 버그는 애플리케이션 상태를 손상시킨다. 예를 잘못된 정보가 데이터베이스에 적용되면 수정하기 훨씬 어려워진다. 이러한 번거로움을 줄이려면 빠른 실패 원칙을 사용해야한다.

## 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

### 프로세스 외부 의존성의 두 가지 유형

- 관리 의존성
    - 애플리케이션에서 전체를 제어할 수 있는 프로세스 외부 의존성이다.
    - 해당 의존성과의 상호 작용은 외부에서 볼 수 없고, 대표적인 예로 데이터베이스가 있다.
    - 외부 시스템은 데이터베이스에 직접 접근하지 않고 애플리케이션이 제공하는 API를 통해 접근한다.
    - 통합 테스트 시 실제 인스턴스를 사용한다.
- 비관리 의존성
    - 애플리케이션이 전체를 제어할 수 없는 프로세스 외부 의존성이다.
    - 해당 의존성과 상호 작용인한 사이드 이펙트를 외부에서 볼 수 있다.
    - 통합 테스트 시 목으로 대체하여 사용한다.

❗️식별할 수 있는 동작이란 A 애플리케이션의 상호 작용으로 인한 사이드 이펙트가 B 애플리케이션에서도 볼 수 있는 것을 의미한다. 그렇기 때문에 비관리 의존성은 목으로 대체하여 다른 애플리케이션의 테스트 결과에 영향이 없도록 해야한다.

관리 의존성이면서 비관리 의존성인 외부 의존성은 대표적인 예로 데이터베이스의 일부 테이블만 접근 권한을 허용해 데이터베이스를 공유하는 상황이 있다. 이러한 경우에는 공유된 테이블은 비관리 의존성으로 간주하여 목으로 대체하고 나머지는 관리 의존성으로 간주하여 실제 인스턴스를 사용하여 테스트 해야한다. 또한 통합 테스트에서 실제 데이터베이스를 사용할 수 없는 경우에는 통합 테스트를 작성하지 말고 도메인 모델에 대한 단위 테스트에 많은 노력을 기울여야한다.

통합 테스트는 동일한 프로세스 내에서 테스트를 진행하기 때문에 비관리 의존성만 목으로 대체하고 관리 의존성은 실제 인스턴스를 사용하여 검증 단계에서 외부 클라이언트 관점에서 최종 상태를 확인할 수 있다. (동일 프로세스 내에 존재하기 때문에 가능) 이와 반대로 엔드 투 엔드 테스트는 외부 클라이언트를 모방해서 테스트를 진행하기 때문에 관리 의존성에 대해서 직접 확인해서는 안 되고, 애플리케이션을 통해 간접적으로 확인해야 한다.

## 의존성 추상화를 위한 인터페이스 사용

### 인터페이스와 느슨한 결합

인터페이스를 사용하는 주된 목적은 다음과 같다.

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하기 위해. (DIP)
- 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP를 지키기 위해.

위 목적을 달성하기 위해 인터페이스를 사용하는 건 좋지만 구현체가 하나만 존재하는 상황에서 인터페이스를 사용하는 것은 바람직하지 않다. 오히려 아직 일어나지 않은 일에 대비하기 위해 사용한 인터페이스가 코드의 유지 보수 비용만 증가시킬 뿐이다. 구현체가 하나만 존재하는 상황에서 인터페이스를 사용해야 하는 상황은 비관리 의존성을 목으로 대체해야할 때다. 하지만 이 부분도 Mockito 라이브러리를 사용하면 구현체도 목 객체로 만들어서 사용할 수 있기 때문에 꼭 인터페이스를 사용하지 않아도 된다.

❗️번외로 스프링은 Proxy기반의 AOP를 사용한다. 이때 사용되는 Proxy 객체는 CGLIB를 사용하기 전에는 JDK Dynamic Proxy를 사용하여 프록시 객체를 만들었었다. JDK Dynamic Proxy는 반드시 인터페이스가 존재해야만 프록시 객체를 만들 수 있었기 때문에 구현체가 하나더라도 인터페이스를 만들었었다. 하지만 CGLIB는 구현체도 프록시 객체를 만들 수 있기 때문에 구현체가 하나인 상황에서 인터페이스를 사용하지 않아도 된다.