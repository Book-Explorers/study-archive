# 3. 단위 테스트 구조

3장 단위 테스트 구조에서 주로 다루는 내용은 단위 테스트의 구조, 좋은 단위 테스트 명명법, 매개변수화된 테스트 작성, Fluent Assertions 사용법을 다룬다.

### 단위 테스트를 구성하는 방법

**AAA 패턴 사용**

AAA 패턴은 arrange, act, assert 세 부분으로 나눌 수 있다.

BDD(Behavior Driven Development) 기반의 테스트에서 사용되는 given, when, then과 같은 개념이다.

유일한 차이점은 개발자가 아닌 일반 사람에게는 given, when, then이 더 읽기 쉽다는 것이다.

이 패턴들은 테스트 스위트내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다.
이렇게 일관성있게 테스트 코드를 작성하면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있으며 테스트 코드의 유지 보수 비용이 줄어든다는 장점이 있다.

**arrange(given)**

준비 구절은 테스트 대상 시스템(System Under Test)과 해당 의존성을 원하는 상태로 만드는 단계.

**act(when)**

실행 구절은 준비 구절에서 만든 SUT로 테스트 하려는 메서드를 호출하고 준비된 의존성을 전달한다.

반환 값이 존재하면 반환 값을 캡처한다.

**assert(then)**

검증 구절은 반환 값이나 협력자(공유 의존성, 변경 가능한 비공개 의존성)의 최종 상태와 호출한 메서드 즉, 행위 등의 검증한다.

```java
public class UsersServiceTest {

		@Test
    @DisplayName("회원 가입 실패 - DataAccessException")
    public void failureSignup_01() {
        // given
        UsersRepository userRepository = Mockito.mock(UsersRepository.class);
        UserService userService = new UserServiceImpl(userRepository); // SUT
        Users users = Users.builder()
                .email("test@gmail.com")
                .name("한규빈")
                .nickname("coby")
                .password("test123412!")
                .phoneNumber("01011111111")
                .build();
				
        doThrow(new DataIntegrityViolationException("insert fail"))
                .when(usersRepository).save(any());

        // when
        assertThrows(ServiceException.class,
                () -> usersService.signup(users));

        // then
        verify(usersRepository, times(1))
                .save(any());
    }
}
```

TDD를 실천할 때는 아직 기능이 어떻게 동작할지 충분히 알지 못하기 때문에 기대하는 동작으로 윤곽을 잡은 다음 즉, 검증문을 먼저 작성하고 준비 구절과 실행 구절을 작성하는 것이 좋다. 하지만 제품의 코드가 이미 작성이 되어 있다면 테스트를 작성할 시점에는 무엇을 예상하는지 이미 알고 있으므로 준비 구절부터 작성하는 것이 좋다.

**여러 개 준비, 실행, 검증 구절 피하기**

이런 구조의 테스트는 테스트가 한 번에 너무 많은 것을 검증한다는 의미다. 즉, 단위 테스트보다 통합 테스트에 더 가깝다는 의미다. 이러한 테스트 구조는 단위 테스트 범주에 있게끔 보장하고 간다하고 빠르며 이해하기 쉽게 하나의 실행만 가지는 테스트로 리팩토링해야한다.

**테스트 내 if 문 피하기**

if 문이 있는 단위 테스트는 안티 패턴이다. 단위 테스트든 통합 테스트든 테스트 코드 내에 if 문이 존재하면 한 번에 너무 많은 것을 실행, 검증한다는 의미다. 이런 테스트 코드는 테스트를 읽고 이해하기 어렵게 만들기 때문에 반드시 여러 테스트로 나누는 리팩토링을 해야한다.

여담으로 OOP 에서도 instanceof keyword가 자주 등장하면 OOP의 다형성 특성을 살리지 못 한 코드이면서 안티 패턴이기 때문에 리팩토링 대상인 것 처럼 테스트 코드에서도 마찬가지다.

**각 구절은 얼마나 커야 하는가?**

- **준비 구정일 가장 큰 경우**
  - 일반적으로 준비 구절이 실행, 검증 구절보다 크다.
  - 하지만 준비 구절이 너무 크다면 같은 테스트 클래스 내 private method 또는 별도의 팩토리 클래스로 도출해서 사용하는 것이 좋다.
  - 준비 구절에서 코드 재사용에 도움되는 두 가지 패턴으로 Object Mother, Test Data Builder 패턴이 있다. (찾아보기)
- **실행 구절이 한 줄 이상인 경우를 경계하라**
  - 실행 구절은 보통 한 줄이다.
  - 실행 구절이 두 줄 이상인 경우 불변 위반(invariant violation)이 발생할 수 있기 때문에 캡슐화가 깨질 수 있다. 여기서 등장하는 불변은 immutable이 아니라 invariant이다. 즉, 변해야 할 것이 변하지 않아서 문제가 발생할 수 있다는 의미이다.
  - 실행 구절이 두 줄 이상인 경우 클라이언트에게 메서드 호출을 강요하게 되는데 이때 클라이언트가 실수에서 호출해야할 코드를 호출하지 않은 경우 위에서 언급한 문제가 발생할 수 있다. 그렇기 때문에 클라이언트가 단일 공개 메서드만 호출해도 불변 위반이라는 모순이 발생하지 않도록 코드를 작성해야 한다.
- **검증 구절에는 검증문이 얼마나 있어야 하는가**
  - 동작 단위 테스트는 여러 결과를 낼 수 있으며, 검증하려는 테스트 코드 안에서 모든 결과를 평가하는 것이 좋다.
  - 검증 구절이 너무 많아지면 SUT에서 호출한 메서드가 반환하는 객체 내에 검증하는 코드를 작성하는 것이 좋을 수 있다. 그러면 단일 검증문으로 반환 결과를 검증할 수 있다.
- **종료 단계는 어떤가**
  - 단위 테스트는 프로세스 외부에 종속적이지 않기 때문에 종료 구절이 필요없다. 종료 구절은 통합 테스트의 영역이다.
- **테스트 대상 시스템 구별하기**
  - 테스트하려는 동작의 진입점은 오직 하나만 존재할 수 있다. (실행 구절이 한 줄 이상인 경우를 경계하라 이 부분과 연관이 있네)
  - 객체 그래프가 큰 경우 SUT를 찾기 힘들 수 있다. 그렇기 때문에 테스트 코드 내의 SUT의 변수 이름을 xxxSUT로 짖는게 나을 수 있다.
- **준비, 실행, 검증 주석 제거하기**
  - 빈 줄로 준비 구절, 실행 구절, 검증 구절이 구분이 가능하다면 주석을 제거하는 게 간결성과 가독성을 향상시킬 수 있다.

단위 테스트를 작성할 땐 단순히 기능을 나열하는 방식이 아닌 경험을 바탕으로 스토리가 존재하게 끔 작성해야한다. 즉, 애플리케이션 동작에 대해 고수준의 명세가 존재해야하며 이 명세는 개발자뿐만 아니라 비즈니스 담당자에게도 의미가 있어야한다.

### 테스트 간 테스트 픽스처 재사용

테스트에서는 언제 어떻게 코드를 재사용하는지 아는 것이 중요. 이렇게 테스트 간에 재사용하여 SUT로 전달되는 파라미터를 테스트 픽스처라 한다.

테스트 픽스처를 준비하기 위해서는 많은 코드를 작성해야한다. 이러한 코드는 별도의 메서드나 클래스로 도출한 후 테스트 간에 재사용하는 것이 좋다.

테스트 픽스처를 준비하는 방법은 세 가지가 존재한다.

1. 테스트 생성자, 자바 기준 @BeforeEach 등에서 픽스처의 인스턴스화
   1. 생성자나 @BeforeEach에서 픽스처를 인스턴스화 하면 테스트 간의 높은 결합도가 생기는 안티 패턴이다.
   2. 테스트만 보고 어떤 역할을 하는 테스트인지 한 번에 알기 어렵기 때문에 가독성을 저하시킨다.
2. **private factory method를 선언하여 픽스처의 인스턴스화**
   1. **테스트 코드를 짧게 하면서 의미있는 메서드 이름을 사용하여 가독성을 향상시킬 수 있다.**
   2. **메서드를 충분히 일반화한다면 테스트가 서로 결합되지 않는다.**
3. base class의 생성자를 사용하여 테스트 전부 또는 대부분에 사용되는 픽스처의 인스턴스화
   1. 상위 클래스 생성자에서 픽스처를 인스턴스화 하고 하위 클래스에서 이를 확장하여 재사용하는 방법

위 방법 중 2번이 가장 선호 되면서 많이 사용되는 방법이다.

### 단위 테스트 명명법

올바른 명칭을 사용하여 테스트 코드 메서드의 이름을 짖는 것이 테스트가 검증하는 내용과 동작을 이해하는데 도움된다.

[테스트 대상 메서드]_[시나리오]_[예상 결과]식의 엄격한 명명 규칙은 동작 대신 구현 세부 사항에 집중된 규칙이기 때문에 미래의 코드 작성자와 동료들에게 테스트가 검증하는 내용과 동작 그리고 비즈니스 요구 사항과 어떤 관련이 있는지 이해하는데 충분한 도움이 되지 못 하며 테스트 스위트의 유지비가 늘어난다.

오히려 표현의 자유를 허용하여 엄격한 명명 규칙을 따르지 않고 영어 구문으로 작성하는 것이 더 효과적이다. 비개발자에게 시나리오를 설명하는 것처럼 테스트 코드 메서드의 이름을 짓는다고 생각하면 조금 수월하게 지을 수 있다. 단 메서드 이름에 SUT 메서드의 이름을 포함하면 안된다. SUT는 동작 단위로 검증할 수 있는 진입점 또는 API다. 즉, 동작을 호출하는 수단일 뿐이다. 메서드에 이름에 SUT 메서드 이름을 포함하게 되면 SUT 메서드 코드의 구현 세부 사항과 테스트 간의 결합도가 높아지게되고 테스트 스위트의 유지 보수성에 부정적인 영향을 미친다. 마지막으로 메서드의 이름이 길어지는 경우 underscore를 사용하면 가독성을 향상시킬 수 있다.

### 검증문 라이브러리를 사용한 테스트 가독성 향상

JUnit Jupiter에서 제공하는 Assertion과 AssertJ, Hamcrest 등을 사용하여 검증문에 가독성을 향상시킬 수 있다. Assertion보다 더 많은 기능을 가진 AssertJ를 사용하는 것을 권장.

https://velog.io/@bonjugi/assertj-vs-junit

```java
public class ProductCalculateTest {

	@Test
	@DisplayName("상품 할인 가격 측정 테스트 - 상품 가격 100,000, 할인율이 10%인 경우 할인가는 90,000원")
	public void productCalculateDiscountTest_01() {
          // given
          Product product = Product.builder()
                  .productCategoryPath("001001001")
                  .name("coby 맨투맨")
                  .price(100000)
                  .discountRate(10)
                  .useOption(false)
                  .optionDepth(0)
                  .quantity(1000)
                  .soldOut(false)
                  .deleted(false)
                  .build();
      
          // when
          product.calculateDiscountPrice();
	
          // then
          // JUnit Jupiter의 Assertion 사용
          // assertEquals(expected, actual)
          assertEquals(90_000, product.getDiscountPrice());
	
          // AssertJ의 Assertion 사용
          // assertThat(actual).isEqualTo(expected)
          assertThat(product.getDiscountPrice()).isEqualTo(90_000);
	}
}
```