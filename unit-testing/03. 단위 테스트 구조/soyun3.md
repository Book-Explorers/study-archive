# 03 단위 테스트 구조

<aside>
💡 03장에서 다루는 내용
- 단위 테스트 구조 
- 좋은 단위 테스트 명명법
- 매개변수화된 테스트 작성
- Fluent Assertions 사용

</aside>

# 3.1 단위 테스트를 구성하는 방법

준비, 실행 , 검증 패턴을 사용해 단위 테스트를 구성하는 방법과 피해야 할 함정

그리고 테스트를 가능한 읽기 쉽게 만드는 방법을 알아보자 

## 3.1.1 AAA 패턴 사용

Arrange 준비 

Act 실행 

Assert 검증 

```jsx
public class CalculatorTests

{
[Fact]
public void Sum_of_two_numbers()

{
//준비
double first = 10;
double second = 20;
var calculator = new Calculator();

//실행
double result = calculator.Sum(first, seconde) 

//검증
Assert.Equal(30,result);

}
}
```

- 준비 구절에서는 테스트 대상 시스템SUT, System Under Test과 해당 의존성을 원하는 상태로 만든다.
- 실행구절에서는 SUT 에서 메서드를 호출하고 준비된 의존성을 전달하며 출력이 있으면 출력값을 캡쳐한다.
- 검증구절에서는 결과를 검증한다.
    - 결과는 반환값이나 SUT와 협력자의 최종상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.

<aside>
💡 Given - When - Then 패턴
준비구절 - 실행구절 - 검증구절
AAA패턴과 차이없지만 더 읽기 쉽다

</aside>

테스트 작성시 보통 준비구절부터 시작한다. 하지만 검증구절부터 시작하는 것도 가능하다. 

테스트 주도 개발 TDD 을 할때, 기대하는 동작으로 윤곽 잡고 기대에 부응하는 시스템을 어떻게 개발할지 아는 것이 좋다. 

- 문제해결 방식

특정 동작이 무엇을 해야할지 목표를 생각하면서 시작한다음에 실제 문제 해결!

다른 것을 하기 전에 먼저 검증문을 작성하는 것은 단지 사고 과정의 형식이다. 

## 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

때로는 준비, 실행 또는 검증 구절이 여러 개 있는 테스트를 만날 수 있다. 이런 테스트는 여러 테스트로 나눠서 해결한다. 

검증구절(어쩌면 준비 구절)로 구분된 여러 개의 실행 구절을 보면, 여러 개의 동작단위를 검증하는 테스트를 뜻한다. 

이런 테스트는 단위테스트보다는 통합테스트이기에 이런 구조는 피하는 것이 좋다. 

각 동작을 고유의 테스트로 도출해야한다. 

항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 좋다. 

## 3.1.3 테스트 내 if문 피하기

if 문이 있는 단위 테스트, 통합테스트, 테스트는 모두 안티 패턴이다. 

모두 분기가 없는 간단한 일련의 단계여야 한다. 

if문이 있다는 것은 한 번에 너무 많은 것을 검증한다는 표시한다. 반드시 여러 테스트로 나눠야한다. 

## 3.1.4 각 구절은 얼마나 커야 하는가?

AAA 패턴으로 시작할 때 보통 각 구절의 크기가 얼마나 되는지 질문한다. 

테스트 크기 구절에 따라 테스트가 끝난 후에 정리하는 종로 구절은 각기 다른 지침으로 만들어진다. 

### 준비 구절이 가장 큰 경우

준비구절이 실행과 검증 합친 것보다 훨씬 크면 

같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다 .

준비 구절에 코드 재사용에 도움이 되는 두 가지 패턴으로 오브젝트 마더 Object Mother와 테스트 데이터 빌더 Test Data Builder가 있다. 

- [ ]  

### 실행 구절이 한 줄 이상인 경우를 경계해라

실행구절은 보통 코드 한 줄이다. 실행 구절이 두줄 이상 경우 SUT의 공개 API에 문제가 있을 수 있다. 

이 문제에 대한 예시를 보자

한줄로 된 실행구절

```jsx
[Fact]
public void Purchase_succeeds_when_enough_inventory()

{
//준비
var store = new Store();
store.AddInventory(Product.Shampoo, 10);
var customer= new Customer();

//실행
bool success = customer.Purchase(store,Product.Shampoo,5);

//검증
Assert.True(success);
Asser.Equal(5, sotre.GetInventory(Product.Shampoo));
}
```

두 줄로 된 실행구절

이건 SUT에 문제가 있다는 이야기

```jsx
[Fact]
public void Purchase_succeeds_when_enough_inventory()

{
//준비
var store = new Store();
store.AddInventory(Product.Shampoo, 10);
var customer= new Customer();

//실행
bool success = customer.Purchase(store,Product.Shampoo,5);
//재고가 감소되는데 Purchase()호출이 성공을 반환하는 경우에만 수행한다. 
success.RemoveInventory(success, Product.Shampoo, 5);

//검증
Assert.True(success);
Asser.Equal(5, sotre.GetInventory(Product.Shampoo));
}
```

문제점:

단일 작업을 수행하는데 두개의 메서드 호출이 필요하다는 것!

새 버전은 테스트 자체는 문제가 되지 않는다. 

테스트는 구매 프로세스라는 동일한 동작 단위를 검증한다. 

customer 클래스의 API에 문제가 있으며 , 

클라이언트에게 메서드 호출을 더  강요해서는 안된다. 

비즈니스 관점에서 구매가 정상적으로 이뤄지면 고객의 제품 획득과 매장 재고 감소라는 두 가지 결과가 만들어진다. 이러한 결과는 같이 만들어야하고 이는 단일한 메서드가 있어야한다는 뜻이다. → 로직 담은 하나의 메서드로 해라

그렇지 않으면 클라이언트 코드가 첫번째 메서드만 호출하고 두번째 메서드를 호출하지 않으면

제품을 얻고 재고는 줄어들지 않는 모순(”불변 위반 invariant violation”)이 생긴다. 

이러한 잠재적 모순으로부터 코드를 보호하는 행위를 캡슐화encapsulation라고 본다. 

코드 캡슐화를 항상 지킴으로써,

 클라이언트 코드에 의존하지 않고 불변을 지키는 한, 불변 위반을 초래할 수 있는 잠재적 행동을 제거한다. 

비즈니스 로직에서는 실행구절을 한 줄로 하는 지침을 대부분 코드에 적용되지만

유틸리티나 인프라 코드는 덜 적용된다. 

## 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가

테스트당 하나의 검증을 갖는 지침은 

가능한 한 가장 작은 코드를 목표로 하는 전제를 기반으로 두고 있다. 

하지만 이 전제는 올바르지 않다. 

단위 테스트의 단위는

- 동작의 단위이다!
- 코드의 단위가 아니다!

단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다. 

그렇지만 검증 구절이 너무 커지는 것은 경계해야한다. 제품 코드에서 추상화가 누락됐을 수도 있다. 

예로 SUT 에서 반환된 객체의 모든 속성을 검증하는 것보다 객체 클래스 내에 적절한 동등 멤버 equality member를 정하는 것이 좋다. 그러면 단일 검증문으로 객체를 기대값과 비교할 수 있다. 

→ isEqualTo (속성값) 같다 라고 검증했는데 여기서 말하는 멤버 정의는 객체 내에 equals 오버라이딩해서 

그 값이 같은지 검증하라는 뜻인가?

## 3.1.6 종료 단계는 어떤가

준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다. 

예를 들면 테스트에 의해 작성된 파일을 지우거나 데이터 베이스 연결을 종료하는데 해당 종료 구절을 사용한다. 

종료는 일반적으로 별도 메서드로 도출되어 클래스 내 모든 테스트에서 재사용된다. 

AAA패턴에는 이 단계를 포함하지 않는다. 

대부분 단위 테스트는 프로세스 외부에 종속적이지 않기 때문에 처리해야할 사이트 이펙트도 남기지 않아서 이러한 종료 구절이 필요없다. 종료는 통합 테스트 영역이다. 

## 3.1.7 테스트 대상 시스템 구별하기

sut 테스트하려는 메소드를 가진 클래스, mut 내가 테스트할 메서드

SUT는 애플리케이션에서 호출하고자 하는 동작에 대한 진입점을 제공한다. 

동작은 여러 클래스로도 있을 수 있고 단일 메서드로 작을 수도 있다. 오직 하나만 존재할 수 있는 진입점은 이런 동작을 수행할 하나의 클래스이다. 

그래서 SUT를 의존성과 구분하는 것이 중요하다. 

특히 SUT가 만들기까지 과정이 길 경우, 테스트 대상을 찾는데 시간을 너무 많이 들일 필요가 없다. 

그렇게 하기 위해 테스트 내 SUT 이름을 sut로 하라

의존성과 SUT 구별하기 

```jsx
public class CalculatorTests

{
[Fact]
public void Sum_of_two_numbers()

{
//준비
double first = 10;
double second = 20;
var sut = new Calculator();

//실행
double result = sut.Sum(first, second);

//검증
Assert.Equal(30,result);
}

}
```

## 3.1.8 준비,실행, 검증 주석 제거하기

테스트 내에서 특정부분이 어떤 구절에 속해있는지 파악하는데 많은 시간 안들이게 세 구절을 구분하는게 중요하다 

빈 구절로 구분하는게 단위 테스트에서 효과적이다.

하지만 대규모 테스트에서는 잘 작동하지 않는다. 대규모 테스트에서는 준비 단계에 빈 줄을 추가해 설정 단계를 구분할 수 있다. → 같은 말 아녀?

- AAA패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라
- 그렇지 않으면 구절 주석을 유지하라

# 3.2 xUnit 테스트 프레임워크 살펴보기

xUnit은 Nunit보다 더 간결하고 깨끗하다. 테스트 간에 구성 로직을 공유해야하면 생성자 내에 배치할 수 있다. 

모든 테스트에 공유하는 준비 및 종료 로직

```jsx
public class CalculatorTests : IDisposable
{
private readonly Caculator _sut;

//클래스 내 각 테스트 이전에 호출
public CalculatorTests()
{
 _sut = new Calculator();
}

[fact]
public void Sum_of_two_numbers()
{
//
}

//클래스 내 각 테스트 이후에 호출
public void Dispose(){

_sut.CleanUp();
}

}
```

xUnit 제작자는 프레임워크를 단순하게 하고자 했다. 

이전에 추가 구성([TestFixture] 또는 [Setup])이 필요했던 많은 개념이 이제 컨벤션convention과 

내장 언어 구조에 의존하게 됐다. 

단위 테스트를 작성할 때는 테스트가 제품코드 기능을 무조건 나열하면 안된다!!!

사고방식을 가져야한다. 

- 각 테스트는 이야기가 있어야 한다.
    - 이 이야기는 문제 영역에 대한 개별적이고 원자적인 사실이나 시나리오
    - 테스트 통과 = 사실 또는 시나리오가 실제 사실이란 증거!
    - 테스트 실패 = 이야기가 더 이상 유효하지 않아
        - 테스트를 다시 작성하거나
        - 시스템 자체를 수정해야한다.

# 3.3 테스트 간 테스트 픽스처 재사용

테스트에서 언제 어떻게 코드를 재사용하는지 아는 것이 중요하다

준비 구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화 하기 좋은 방법이다. 

테스트를 재사용하기 좋은 방법은 두 가지가 있는데 

하나만 유용하다! 다른 것은 오히려 유지비를 증가시킨다. 

<aside>
💡 테스트 픽스처란?
두 가지 공통된 의미가 있다. 
1. 테스트 실행 대상 객체이다. 이 객체는 정규 의존성, 즉 SUT로 전달되는 인수다. 데이터베이스에 있는 데이터나 하드 디스크의 파일일 수도 있다. 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 따라서 픽스처 - 란 단어가 나왔다. 
2. 테스트가 포함된 클래스를 표시하는 특성. NUnit테스트 프레임 워크에서 비롯된다. NUnit에서 [TestFixture]를 의미힌다.

</aside>

테스트 픽스처를 재사용하는 올바르지 않은 방법!

은 테스트 생성자에서 픽스처를 초기화하는 것이다. 

이 경우 중요한 단점이 있다. 

- 테스트 간 결합도가 높아진다
- 테스트 가독성이 떨어진다.

## 3.3.1 테스트 간 높은 결합도는 안티 패턴이다

테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다!

이 지침을 따르기 위해 테스트 클래스에 공유 상태를 두지 말아야한다. 

## 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용

준비코드를 생성자로 추출할 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다. 

테스트만 보고는 더 이상 전체 그림을 볼 수 없다. 테스트 메서드가 무엇을 하는지 이해하려면 클래스의 다른 부분도 봐야한다. 

준비로직이 별로 없더라도 테스트 메서드로 바로 옮기는 것이 좋다. 

독립적인 테스트는 이러한 불확실성을 두지 않는다. 

## 3.3.3 더 나은 테스트 픽스처 재사용법

생성자 사용 말고 다른 방법으로 테스트 픽스처를 재사용해보자. 

두번째 방법은 테스트 클래스에 비공개 팩토리 메서드private facotry method를 두는 것이다.

공통 초기화 코드를 비공개 팩토리 메서드로 추출해 테스트 코드를 짧게 하고 

동시에 테스트 진행상황에 대한 전체 맥락을 유지할 수 있다. 

또한 테스트가 서로 결합되지 않는다. 

 

```jsx
Store store = CreateStoreWithInventory(Product.shampoo, 10);
```

테스트 픽스처 재사용 규칙의 예외

테스트 대부분에 사용되는 생성자에 픽스처를 인스턴스화할 수 있는데  - 추상클래스를 만들어서 확장

예로 데이터베이스와 작동하는 통합테스트와 같은 경우가 있다. 

모든 테스트에 데이터베이스 연결이 필요하고 이 연결을 한 번 초기화한 다음에 어디에서나 재사용할 수 있다. 

그러나 기초 클래스를 둬서 개별 테스트 클래스가 아니라 클래스 생성자에서 데이터베이스 연결을 초기화하는 것이 더 합리적이다.  → 상위클래스 데이터베이스 생성하는 방식

인스턴스화 시키는 것보다 상위클래스로.

테스트 픽스처를 준비하는 방법은 세 가지 존재한다. 

1. **beforeEach나 생성자 를 쓰면 같은 인스턴스에 영향줘서 안티패턴 (중복코드)**
    1. **안티패턴!**
        1. **테스트 간의 “높은 결합도”(성공되던 코드가 수정후 실패함, 영향이 전파됨)가 생기는 안티패턴**
        2. **유저 변수가 추가되면 코드 변경이 추가되어야한다.** 
            1. **결합도 높다: 근데 문제 생기면 전파된 연결된 모든 코드를 고쳐줘야함!**
2. private facotory method 선언해서 픽스처의 인스턴스화
    1. 테스트코드를 짧게 하면서 의미있는 메서드 이름을 사용!
    2. 하면서 가독성이 향상시킬 수 있다. 
3. base class의 생성자를 사용하여 테스트 전부 또는 대부분에 사용되는 픽스처이 인스턴스화
    1. 상위 클래스 생성자에서 픽스처를 인스턴스화 하고 하위 클래스에서 이를 확장하여 재사용하는 반법, ( 상속말고 추상클래스로 재사용하는 방법도 있다. (상위 클래스에서 생성자에 초기화됨 코드 재사용)

데이터베이스로 예시를 들었으니 

인스턴스 재활용

2번이 가장 선호되면서 많이 사용되는 방법이다. 

3번 근데 언제 써야하지? 생각했을 때

지금 스프링이 의존성으로 다 해결해주고 있음

# 3.4 단위테스트 명명법

[테스트 대상 메서드]_[시나리오]_[예상결과]

- 테스트 대상 메서드: 테스트 중인 메서드의 이름
- 시나리오: 메서드를 테스트하는 조건
- 예상 결과: 현재 시나리오에서 테스트 대상 메서드에 기대하는 것

쉬운 영어로 작성할 것

Sum_of_tow_numbers() 가 낫다. 

Sum_TwoNumbers_ReturnsSum()

## 3.4.1 단위 테스트 명명 지침

- 엄격한 명명 정책을 따르지 않는다.
- 문제 도메인에 익숙한 비개발자도 알아볼 수 있도록 짓는다

<aside>
💡 테스트명 내 테스트 대상 메서드
테스트 이름에 SUT의 메서드 이름을 포함하지 말라 
코드를 테스트하는 것이 아니다. 애플리케이션 동작을 테스트하는 것이다!!
SUT은 단지 진입점, 동작을 호출하는 것 뿐이다. 

이 지침의 유일한 예외는 유틸리티 코드를 작업할 때다. 유틸리티코드는 비즈니스 로직없고 코드 동작이 보조기능에 크게 벗어나지 않기 때문에 SUT메서드 이름을 사용해도 괜찮다.

</aside>

전) public void IsDeliveryValid_InvalidDate_ReturnsFalse()

후) public void Delivery_with_a_past_date_is_invalid()

# 3.5 매개변수화된 테스트 리팩터링하기

매개변수화된 테스트를 사용하면 테스트코드의 양을 크게 줄일 수 있지만, 비용이 발생한다. 이제 테스트 메서드가 나타내는 사실을 파악하기가 어려워졌다. 매개변수가 많을수록 더 어렵다. 

테스트 코드의 양과 그 코드의 가독성은 서로 상충된다. 

동작이 복잡하면 매개변수화된 테스트를 사용하지 말라. 긍정적인 테스트 케이스와 부정적인 테스트 케이스 모두 각각 고유의 테스트 메서드로 나타내라. 

## 3.5.1 매개변수화된 테스트를 위한 데이터 생성

## 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상

```jsx
Assert.Equal(30, result);
를 
result.Should().Be(30);
```

모든 이야기는 다음과 같은 특정 패턴을 따른다. 

[주어] [행동] [목적어]

이 규칙을 코드에도 적용하면 가독성이 좋다. 

라이브러리 사용은 프로젝트에 의존성을 추가한다는 단점이 있지만 가독성 향상에는 좋다.  

Junit jupiter

보다 기능이 더 많다

Assertj의 Assertion 사용하는 이유는 체이닝할 수 있다

assertThat(product.getDiscoun),isEqualTo()
