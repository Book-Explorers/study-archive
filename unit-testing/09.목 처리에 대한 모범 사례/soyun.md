# 09장 목처리에 대한 모범 사례

*서드파티: 제3자(외부생산자)

*래퍼:

<aside>
💡 9장에서 다루는 내용
- 목의 가치를 극대화하기
- 목을 스파이로 교체하기
- 목 처리에 대한 모범 사례

</aside>

목은?

 테스트 대상 시스템과 의존성 간의 상호 작용을 

모방하고 검사하는데 도움이 되는 테스트 대역이다. 

목의 사용은?

목은 비관리 의존성(외부 애플리케이션에서 식별할 수 있음)에만 적용해야한다. 

### 목표

목에 대해 리팩터링 내성과 회귀 방지를 최대화해서 

최대가치의 통합테스트를 개발하는데 도움이 되는 지침을 알아본다. 

### 목의 가치를 극대화하기

비관리 의존성에만 목을 사용하게끔 제한하는 것이 중요하다. 

### 시스템 끝에서 상호 작용 검증하기

통합테스트에서 사용했던 목이 회귀 방지와 리팩터링 내성 측면에서 이상적이지 않은 이유와 이를 해결하는 방법을 알아보자. 

- 목을 사용할 때 시스템 끝에서 비관리 의존성과의 상호작용을 검증하라

회귀 방지는 테스트 중에 실행되는 코드 양에 대한 함수다. 비관리 의존성과 통신하는 마지막 타입을 목으로 처리하면 통합 테스트가 거치는 클래스의 수가 증가하므로 보호가 향상된다. 

예제에서 

사용자 정의 클래스에 대한 호출을 검증한 것과 외부 시스템에 전송한 실제 텍스트 메시지를 검증하는 것사이에는 큰 차이가 있다.

텍스트 메시지는 외부에서 식별할 수 있는 유일한 사이드 이펙트이다. 

이러한 메시지를 생성하는데 필요한 클래스들은 구현 세부 사항이다. 

그래서 시스템 끝에서 상호 작용을 확인하면 회귀 방지가 좋아질 뿐 아니라 리팩터링 내성도 향상된다. 

이 식별할 수 있는 값인 텍스트는 잠재적인 거짓양성에 노출될 가능성이 낮아진다. 

리팩터링하더라도 메시지 구조를 유지하는한 테스트가 실패되지 않는다. 

이처럼 코드베이스와의 결합도가 낮기 때문에 리팩터링 내성이 우수하다. 

- 비관리 의존성에 대한 호출은 애플리케이션을 떠나기 전에 몇 단계를 거친다. 마지막 단계를 선택하라. 외부 시스템과의 하위 호환성을 보장하는 가장 좋은 방법이며, 하휘 호환성은 목을 통해 달성할 수 있는 목표다.

### 목을 스파이로 대체하기

스파이는 목과 같은 목적을 수행하는 테스트 대역이다. 스파이는 수동으로 작성하는 반면에 목은 프레임 워크의 도움을 받아 생성한다는 것이 유일한 차이이다. 

시스템 끝에 있는 클래스의 경우 스파이가 목보다 낫다. 

스파이는 검증단계에서 코드를 재사용해 테스트 크기를 줄이고 가독성을 향상시킨다. 

- 테스트에서 검증문을 작성할 때 제품코드에 의존하면 안된다.
- 테스트를 감시자로 생각하라. 모든 것을 재확인하라

### 목 처리에 대한 모범 사례

- 비관리 의존성에만 목 적용하기
- 시스템 끝에 있는 의존성에 대해 상호 작용 검증하기
- 통합 테스트에서만 목을 사용하고 단위테스트에서는 하지 않기
    - 도메인 모델에 대한 테스트 - 단위 테스트 범주
    - 컨트롤러 다루는 테스트 - 통합테스트
    - 목은 비관리 의존성에만 해당, 컨트롤러에서만 이런 의존성을 관리하기 때문에 통합테스트에서 컨트롤러를 테스트할 때만 목 적용해야한다.
- 항상 목 호출 수 확인하기
    - 테스트당 목이 하나일 필요는 없다. ‘단위’는 코드단위가 아니라 동작단위를 의미하기 때문에 필요한 코드 양은 관계없다.
    - 목의 수는 운영에 참여하는 비관리 의존성에만 의존한다.
    - 비관리 의존성과의 통신에서 확인해야할 것은
        - 예상되는 호출이 있는가?
        - 예상치 못한 호출은 없는가.
    - 이런 요구사항은 비관리 의존성과 하위 호환성을 지켜야 하는 데서 비롯된다. 호환성은 양방향이어야한다.
- 보유 타입만 목으로 처리하기
    - 프로세스 내부 의존성에는 적용되지 않는다.
    - 목은 비관리 의존성에만 해당한다. 그렇기에 인메모리 의존성이나 관리 의존성을 추상화할 필요없다. 이런 것들은 있는그대로 사용하라.
        - 비관리 의존성에 접근하는 서드파티 라이브러리 위에 어댑터를 작성하라. 기본타입 대신 해당 어댑터를 목으로 처리!
