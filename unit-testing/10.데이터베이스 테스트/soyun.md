# 10장 데이터베이스 테스트

<aside>
💡 10장에서 다루는 내용
- 데이터베이스 테스트를 위한 전제 조건
- 데이터베이스 테스트 모범 사례
- 테스트 데이터 생명 주기
- 테스트 내 데이터베이스 트랜잭션 관리

</aside>

데이터베이스 테스트를 위한 준비단계

- 데이터베이스 스키마를 추적하고
- 상태기반 데이터베이스 배포 방식과 마이그레이션 기반 데이터베이스 배포 방식의 차이점을 설명
- 상태기반보다 마이그레이션 기반을 선택해야하는 이유를 알아본다.

테스트 중 

- 트랜잭션 관리하는 방법
- 남은 데이터를 정리하는 방법
- 중요하지 않은 부분제거하고 필수 요소 강조해 테스트 작게 하는 방법

### 10.1 데이터베이스 테스트를 위한 전제 조건

- 형상 관리 시스템에 데이터베이스 유지
    - git과 같은 형상관리 시스템에 디비 스키마 저장
    - 데이터베이스 변경 추적할 수 있다
    - 참조 데이터(애플리케이션이 제대로 작동하도록 미리 채워야하는 데이터)도 데이터베이스 스키마이다
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
    - 공유 디비를 사용하면 개발 프로세스를 방해하게 된다.
- 데이터베이스 배포에 마이그레이션 기반 방식 적용
    - 디비 배포 방식 :
        - 1. 상태 기반
            - 배포 중에 비교도구가 스크립트를 생성해서 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지한다. 현상관리에 저장한 SQL 스크립트를 이용해 데이터베이스 작성하는데 사용할 수 있다.
            - 비교도구는 불필요한 테이블 삭제하고 새 테이블 생성하고 컬럼명을 바꾸는 등 모델 데이터베이스와 동기화하는데 필요한 모든 작업을 수행한다.
        - 2. 마이그레이션 기반
            - 데이터베이스를 어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미한다.
            - 자동으로 동기화하기 위한 도구를 쓸 수 없고 업그레이드 스크립트를 직접 작성해야한다.
            - 마이그레이션 기반 방식에서 형상 관리에 저장하는 산출물은 데이터베이스 상태가 아닌 마이그레이션이다.
    - 마이그레이션 기반 방식을 선호하라
        - 데이터 모션이 병합 충돌보다 훨씬더 중요하기 때문
            - 상태기반은 프로젝ㅌ에서 실용적이지 않다
            - 도메인에 특화된 규칙을 적용해야한다.
    
    |  | 데이터베이스 상태  | 마이그레이션 메커니즘 | 장점 |
    | --- | --- | --- | --- |
    | 상태 기반 방식 | 명시적 | 암묵적 | 병합충돌 처리하기 수월하다 |
    | 마이그레이션 기반 방식 | 암묵적 | 명시적 | 데이터모션 문제를 해결하는데 도움된다. |
    |  |  |  |  |

데이터모션은 새로운 데이터베이스 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정이다.

<aside>
💡 마이그레이션을 통해 데이터베이스 스카마에 (참조 데이터를 포함해) 모든 수정 사항을 적용하라. 형상 관리에 마이그레이션이 커밋된 후에 수정하지 말라. 마이그레이션이 잘못된 경우 이전 마이그레이션을 수정하는 대신 새 마이그레이션을 생성하라.

</aside>

상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포는 데이터베이스 스키마의 변경과 배포 방식에 대한 두 가지 다른 접근 방식을 나타냅니다. 각 방식은 데이터베이스를 변경하고 배포하는 과정에서 다른 전략을 사용합니다.

1. **상태 기반 데이터베이스 배포**:
    - **개념**: 상태 기반 데이터베이스 배포는 원하는 최종 상태를 정의하고, 해당 상태로 데이터베이스를 배포하는 방식입니다. 배포 과정에서 데이터베이스의 현재 상태와 원하는 최종 상태를 비교하여 변경이 필요한 부분을 식별하고 적용합니다.
    - **작동 방식**: **배포 전에 최종 상태를 정의**하고, 배포 시점에서 현재 데이터베이스 상태와 비교하여 차이점을 확인합니다. 이 차이점을 해결하기 위해 필요한 변경 사항을 적용하여 데이터베이스를 목표 상태로 업데이트합니다.
    - **예시**: 상태 기반 배포 도구는 Terraform과 같은 인프라스트럭처 관리 도구에서 볼 수 있습니다. 이들은 인프라 상태를 정의하고, 명시된 상태로 인프라를 배포하고 유지합니다.
2. **마이그레이션 기반 데이터베이스 배포**:
    - **개념**: 마이그레이션 기반 데이터베이스 배포는 변경 사항을 일련의 마이그레이션 스크립트로 표현하고, 각 스크립트를 순차적으로 실행하여 데이터베이스를 변경하는 방식입니다.
    - **작동 방식**: 데이터베이스 스키마 변경이 필요할 때마다, 해당 변경 사항에 대한 마이그레이션 스크립트를 작성하고 버전 관리합니다. 배포 시점에서 각 마이그레이션 스크립트를 **순차적으로 실행하**여 데이터베이스를 새로운 상태로 업데이트합니다.
    - **예시**: 대표적인 마이그레이션 도구로는 Flyway, Liquibase 등이 있습니다. 이들은 데이터베이스 변경을 스크립트로 관리하고, 각 스크립트의 실행 여부를 추적하여 일관된 데이터베이스 배포를 지원합니다.

**차이점**:

- **복잡성**: 상태 기반 데이터베이스 배포는 최종 상태를 정의하고, 배포 도구가 현재 상태와의 차이를 계산하여 변경 사항을 적용합니다. 반면 마이그레이션 기반 데이터베이스 배포는 각 변경 사항을 개별적인 마이그레이션 스크립트로 다루기 때문에 복잡성이 높을 수 있습니다.
- **관리 용이성**: 마이그레이션 기반 데이터베이스 배포는 변경 이력을 스크립트로 추적하고 버전 관리하기 용이합니다. 반면 상태 기반 데이터베이스 배포는 최종 상태만을 고려하므로 변경 이력을 관리하기 어려울 수 있습니다.
- **적용 범위**: 상태 기반 데이터베이스 배포는 전체 데이터베이스 상태를 고려하여 배포를 수행하므로 전체 데이터베이스의 일관성을 유지하기 쉽습니다. 반면 마이그레이션 기반 데이터베이스 배포는 각 변경 사항을 순차적으로 적용하므로 일부 오류가 발생할 경우 롤백이 더 쉽습니다.

### 10.2.1 제품코드에서 데이터베이스 트랜잭션 관리하기

비즈니스 연산에 데이터 변경이 포함된다면 모순을 피하고자 이 연산에 포함된 모든 업데이트는 원자적이어야 한다. (원자적 업데이트는 모두 수행하거나 전혀 수행하지 않는 것이다. )

- 데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기
    - 잠재적인 모순을 피하려면 결정 유형을 두 가지로 나눠야한다.
        - 업데이트할 데이터
            - Database클래스 → 리포지터리 : 데이터베이스의 데이터에 대한 접근과 수정을 가능하게 하는 클래스
            - 리포지터리는 수명이 짧다. 데이터베이스 호출이 완료되는 즉시 리포지터리를 폐기할 수 있다. 항상 현재 트랜잭션 위에서 작동한다.
        - 업데이트 유지 또는 롤백 여부
            - Database클래스 → 트랜잭션 : 데이터베이스 업데이트를 완전히 커밋하거나 롤백하는 클래스
            - 트랜잭션은 비즈니스 연산동안 있으며 연산이 끝나면 폐기된다.

별도의 트랜잭션이 아닌 명시적 트랜잭션을 도입해 컨트롤러와 데이터베이스 간의 상호작용을 조정한다. 데이터베이스 호출은 그대로지만 데이터 수정은 커밋되거나 완전히 롤백된다. 

원자적으로 데이터를 수정할 수 있다. 

https://velog.io/@suhongkim98/Transaction

- **작업 단위**로 트랜잭션 업그레이드 하기

Transaction클래스를 작업단위로 업그레이드하면 작업단위의 장점인 업데이트 지연의 장점을 가져갈 수 있다. 

트랜잭션과 달리 작업 단위는 비즈니스 연산 종료 시점에 모든 업데이트를 실행하므로 데이터베이스 트랜잭션의 기간을 단축하고 데이터 혼잡을 줄인다. 데이터베이스 호출 수를 줄이는데도 도움이 된다. 

### 10.2.2 **통합 테스트에서 데이터베이스 트랜잭션 관리하기**

테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라. 

작업 단위를 재사용하는 것은 컨트롤러가 운영환경에서 하는 것과 다른 환경을 만들기 때문에 문제가 된다. 

통합테스트를 가능한 운영환경과 비슷하게 해야한다. 

### 10.3 테스트 데이터 생명 주기

공유 데이터베이스를 사용하면 통합 테스트를 서로 분리할 수 없는 문제가 생긴다. 이를 해결하기 위해 

- 통합 테스트를 순차적으로 실행하라
    - 통합 테스트군은 테스트 병렬처리를 비활성화 한다.
    - 컨테이너를 만들어 테스트를 병럴처리할 수도 있지만 유지 보수 부담이 커서 좋지 않다.
- 테스트 실행 간에 남은 데이터를 제거하라
    - 4가지 방법
    - 각  테스트 전에 데이터베이스 백업 복원
    - 테스트 종료 시점에 데이터 정리
    - 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
    - 테스트 시작 시점에 데이터 정리하기
        - 이 방법이 가장 좋음
        
    - 모든 통합 테스트의 기초 클래스를 두고 기초 클래스에 삭제 스크립트를 작성하라. 이 기초 클래스를 사용해 테스트가 시작할 때마다 삭제 스크립트가 자동으로 실행되도록 할 수 있다.
        - 삭제 스크립트: 일반 데이터를 모두 제거해야하지만 참조 데이터는 제거하지 말아야한다. 나머지 데이터베이스 스키마와 참조 데이터는 마이그레이션으로만 제어돼야한다.

### 10.3 인메모리 데이터베이스 피하기

인메모리 데이터베이스(SQLite)는 일반 디비와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다. 일반 데이터베이스와 인메모리 데이터베이스의 차이로 인해 거짓양성 또는 거짓음성이 발생하기 쉽다. 

→ 로컬디비로 보통많이 한다

### 10.4 테스트 구절에서 코드 재사용하기

비즈니스와 관련없는 기술적인 부분을 비공개 메서드나 헬퍼 클래스로 추출해 재사용하면서 통합 테스트를 짧게 만들어 줄 수 있다. 

- 비공개 팩토리 메서드를 도입해 테스트코드 단축
    - 오브젝트 마더 : 테스트 픽스처(테스트 실행 대상)을 만드는데 도움이 되는 클래스 또는 메서드다.
    - 테스트 데이터 빌더: 준비 구절에서 코드를 재사용하는 목표를 달성하는데 도움이 되는 패턴
    - 상용구가 너무 많이 필요하므로 오브젝트 마더를 쓰는것이 더 좋다고 함
    - 기초 클래스에 팩토리 메서드 넣지 말고, 동일한 클래스에 배치하라
- 실행 구절에서 코드 재사용
    - 컨트롤러 기능을 정의한 대리자를 통해 테스트의 실행구절을 줄인다.
- 검증 구절에서 코드 재사용
    - 헬퍼 메서드를 사용하거나 데이터 검증을 위한 플루언트 인터페이스를 만들어 사용한다.

### 10.4 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?

데이터베이스 컨텍스트를 추가하면 테스트가 느려져 문제가 될 수도 있지만 유지보수성을 위해 성능을 양보하여 절충하는 것이 좋다. 

### 10.5 데이터베이스 테스트 중 읽기 테스트를 해야하는가?

보통 읽기는 테스트하지 않는다. 가장 복잡하거나 중요한 읽기 작업만 테스트하고 나머지는 무시한다. 

읽기에는 도메인이 모델이 필요없다. 이런 추상화 계층이 필요없기 때문에 단위테스트는 소용없고 테스트를 한다면 실제 통합 테스트를 하라

### 10.5 데이터베이스 테스트 중 리포지터리 테스트를 해야하는가?

리포지터리는 데이터베이스 위에 유용한 추상화를 제공한다. 리포지토리를 다른 통합테스트와 독립적으로 테스트해야하는가? 하지만 리포지토리가 도메인 객체와 어떻게 디비에 매핑하는지 테스트하는 것은 유익하더라도 유지비가 높고 회귀방지가 떨어져서 테스트 스위트에 손실이 된다. 

리포지터리는 복잡도가 거의 없고 프로세스 외부 의존성과 통신하므로 코드 유형 다이어그램의 컨트롤러 사분면에 속한다. 리포지터리를 테스트하기에 가장 좋은 방법은 리포지터리가 갖고 있는 약간의 복잡도를 별도의 알고리즘으로 추출하고 해당 알고리즘 전용 테스트를 작성하는 것이다. 

리포지토리에는 sql쿼리만 있다. orm사용할 때는 데이터매핑과 디비 상호작용 분리가 불가능하다. 따라서 리포지토리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트의 일부로 취급하라

