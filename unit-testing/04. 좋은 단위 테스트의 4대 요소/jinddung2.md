## 목표: 가치있는 테스트를 식별하는 방법

- 좋은 단위 테스트의 관점 간 차이점 모색
- 이상적인 테스트 정의
- 테스트 피라미드 이해
- 블랙박스 테스트 및 화이트박스 테스트 사용

좋은 단위 테스트는 소프트웨어 개발 과정에서 중요한 역할을 합니다. 이는 코드의 신뢰성을 높이고, 장기적으로 유지보수를 용이하게 합니다. "좋은 단위 테스트의 4대 요소"로는 회귀 방지, 리팩터링 내성, 빠른 피드백, 그리고 유지 보수성이 있습니다.

**단위테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다.**

### **1. 회귀 방지 (Regression Prevention)**

회귀 방지는 코드 변경 후에도 기존 기능이 올바르게 작동하는지 확인하는 데 중점을 둡니다. 이는 새로운 기능 추가나 버그 수정 과정에서 기존 기능에 영향을 주지 않도록 보장합니다. 회귀 방지를 위한 단위 테스트는 개발자에게 코드 변경의 부작용 없이 안전하게 개선할 수 있는 환경을 제공합니다.

### **2. 리팩터링 내성 (Refactoring Tolerance)**

리팩터링 내성은 코드의 내부 구조를 개선하면서도 기존의 테스트가 계속 통과되도록 하는 것입니다. 이는 코드의 가독성, 효율성, 그리고 확장성을 향상시키는 과정에서 중요합니다. 리팩터링 내성이 높은 단위 테스트는 코드 변경이 기능적인 행동에 영향을 주지 않음을 보증합니다.

테스트에 SUT의 구현 세부 사항이 많이 결합할수록 허위 경보가 많이 생기므로 구현 세부 사항에서 테스트를 분리해야 한다. → SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다.

그럼 어껗게 테코를 짜야할까? 구현 세부 사항 대신 최종 결과를 목표로 하자.

회귀 방지는 처음부터 테스트 스위트에 영향을 크게 미치지만, 거짓 양성은 프로젝트 코드가 많아질수록 테스트 스위트에 크게 미친다.

리팩터링 내성이 우수하려면 테스트의 목적을 `어떻게` 가 아니라 `무엇을` 에 집중해야 한다.

### **3. 빠른 피드백 (Quick Feedback)**

빠른 피드백은 개발 과정 중에 발생할 수 있는 문제를 신속히 식별하고 수정할 수 있게 하는 것입니다. 이는 개발 사이클을 가속화하고, 개발자가 더 효율적으로 작업할 수 있게 합니다. 빠른 피드백을 제공하는 단위 테스트는 문제 해결 시간을 단축하고, 생산성을 높이는 데 기여합니다.

### **4. 유지 보수성 (Maintainability)**

유지 보수성은 테스트 코드가 시간이 지나도 쉽게 이해하고 수정할 수 있어야 함을 의미합니다. 이는 장기적인 프로젝트 관리와 팀 내 지식 공유에 중요합니다. 유지 보수가 용이한 테스트 코드는 프로젝트의 건강을 유지하고, 새로운 팀 멤버가 프로젝트에 기여하기 쉽게 만듭니다.

**이상적인 테스트는 무엇일까?**

이상적인 테스트는 회귀 방지, 리팩터링 내성, 빠른 피드백을 균형있게 제공하면서도 유지 보수가 용이해야 합니다. 하지만, 이 세 가지 요소는 서로 상호 배타적인 특성을 가질 수 있어, 완벽한 균형을 찾는 것은 도전적입니다. 이상적인 테스트는 **테스트의 가치를 극대화**하면서도, **한 가지 요소를 완전히 희생하지 않는 방식**으로 이루어져야 합니다.

- **회귀 방지**와 **리팩터링 내성**은 안정적인 코드베이스 유지에 중요합니다.
- **빠른 피드백**은 개발 사이클을 가속화합니다.
- **유지 보수성**은 테스트 코드의 장기적인 관리에 필수적입니다.

**대중적인 테스트 자동화는 어떻게 이루어져 있을까?**

테스트 자동화의 대중적인 개념으로는 테스트 피라미드가 있습니다. 이는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 적절한 비율을 제안합니다.

- 단위 테스트(70%)는 가장 많은 비중을 차지하며, 빠른 피드백과 유지 보수성에 기여합니다.
- 통합 테스트(20%)는 시스템의 여러 컴포넌트가 함께 잘 작동하는지 검증합니다.
- 엔드 투 엔드 테스트(10%)는 사용자의 관점에서 전체 시스템의 기능을 검증합니다.

또한, 테스트를 **블랙박스**와 **화이트박스** 방법으로 접근하는 것이 중요합니다. 블랙박스 테스트는 시스템의 외부적인 기능과 인터페이스에 초점을 맞추며, 화이트박스 테스트는 내

**Q1:** 단위 테스트에서 회귀 방지와 리팩터링 내성 사이의 균형을 어떻게 맞출 수 있을까요?

1. **추상화 수준 유지:** 테스트가 소프트웨어의 식별 가능한 동작에 집중하도록 하여 구현 세부 사항과의 결합을 최소화합니다. 이는 리팩터링 시 테스트가 그대로 유지될 수 있도록 해주며, 동시에 소프트웨어의 중요한 동작 변경이 발생했을 때 회귀를 잡아낼 수 있게 합니다.
2. **행동 기반 테스트 사용:** 테스트를 작성할 때는 시스템의 내부 구현보다는 외부에서 관찰할 수 있는 행동에 초점을 맞추어야 합니다. 이 방식은 리팩터링이 내부 구현을 변경할 때 테스트가 실패하는 것을 방지하고, 회귀 방지 기능을 유지할 수 있게 돕습니다.
3. **적절한 테스트 커버리지 확보:** 모든 코드 경로와 시나리오를 커버하는 충분한 테스트를 작성하여, 리팩터링 과정에서 의도치 않게 기능이 변경되거나 손상되는 것을 방지합니다. 동시에, 과도한 테스트는 피하며, 중요한 비즈니스 로직에 집중하여 리팩터링 시 테스트 유지 관리 부담을 줄입니다.
4. **모의 객체와 스텁 사용:** 외부 시스템이나 복잡한 의존성을 가진 컴포넌트를 테스트할 때는 모의 객체(mock objects)나 스텁(stubs)을 사용하여, 리팩터링 시 이러한 의존성으로 인한 테스트 실패를 방지합니다. 이는 또한 테스트 실행 속도를 높여 회귀 방지를 위한 빠른 피드백을 제공합니다.

**Q2:** 단위 테스트의 빠른 피드백과 유지 보수성을 동시에 확보하는 전략은 무엇일까요?

1. **테스트의 분리와 조직화:** 테스트를 논리적으로 분리하고, 명확하게 명명하여 각 테스트의 목적과 검증하고자 하는 특정 동작을 쉽게 이해할 수 있도록 합니다. 이는 테스트 코드의 가독성을 높이고, 필요한 경우 빠른 수정을 가능하게 합니다.
2. **지속적 통합(CI) 활용:** 지속적 통합 시스템을 사용하여 코드 변경 사항이 있을 때마다 자동으로 테스트를 실행합니다. 이는 개발 과정에서 신속한 피드백을 제공하며, 문제를 조기에 발견하고 수정할 수 있게 합니다.
3. **적절한 테스트 수준 선택:** 모든 테스트를 단위 테스트로 처리하려 하지 말고, 적절한 수준(단위 테스트, 통합 테스트, 엔드 투 엔드 테스트)에서 테스트를 수행하여, 테스트 실행 시간을 최적화합니다. 단위 테스트는 빠른 피드백을 제공하는 반면, 더 높은 수준의 테스트는 애플리케이션의 다양한 부분 간의 통합을 보장합니다.

### 단어 정리

- 식별할 수 있는 동작"(observable behavior)이란 소프트웨어에서 외부적으로 관찰 가능한 행위
  - 리팩터링의 목적은 이러한 식별할 수 있는 동작을 변경하지 않으면서 코드의 내부 구조(품질)를 개선하는 것입니다. 이 과정에서 코드의 가독성을 향상시키고, 유지보수를 용이하게 하며, 잠재적인 오류를 줄이고자 합니다.
  - 리팩터링을 통해 코드를 변경하더라도, 소프트웨어가 외부에 제공하는 기능과 행위는 그대로 유지되어야 합니다. 이는 사용자나 소프트웨어가 상호 작용하는 다른 시스템이 리팩터링 이후에도 동일한 방식으로 소프트웨어를 사용할 수 있음을 보장합니다.
  - 예를 들어, 어떤 함수의 내부 로직을 더 효율적으로 변경하는 경우, 그 함수를 호출하는 코드는 여전히 같은 결과를 받아야 하며, 함수 호출의 결과로 기대하는 동작에는 변화가 없어야 합니다.
  - 리팩터링은 코드의 식별할 수 있는 동작을 보존하는 전제 하에 진행되므로, 리팩터링 전후로 소프트웨어의 기능적인 테스트가 동일한 결과를 보여야 합니다. 이를 통해 리팩터링이 성공적으로 이루어졌음을 검증할 수 있습니다
- 식별할 수 있는 동작과 인터페이스
  - 이 두 개념은 서로 다른 맥락에서 사용되지만, 공통적인 요소를 가지고 있습니다. 식별할 수 있는 동작과 인터페이스 모두 소프트웨어의 외부적인 상호작용이나 계약을 정의합니다.
  - **식별할 수 있는 동작**은 소프트웨어가 수행하는 작업으로 외부에서 관찰할 수 있는 모든 행위를 말합니다. 이는 소프트웨어가 사용자나 다른 시스템과 상호작용하는 방식을 포함하며, 특정 입력에 대해 예상되는 출력이나 부작용을 의미합니다. 식별할 수 있는 동작의 관점에서 보면, 소프트웨어의 외부적인 '계약'이 어떻게 유지되는지 중요합니다. 즉, 리팩터링을 진행하더라도 이러한 계약이 변경되지 않아야 합니다.
  - **인터페이스**는 객체나 시스템 간의 상호작용을 위한 명시적인 정의를 제공하며, 사용할 수 있는 메서드, 함수, 또는 명령의 집합을 규정합니다. 인터페이스는 다른 코드나 프로그램이 해당 객체나 시스템과 상호작용하는 방법을 정의하는 계약의 역할을 합니다. 이 계약을 통해, 상호작용하는 다른 부분들은 내부 구현을 몰라도 그 기능을 사용할 수 있습니다.
  - 이 두 개념의 교차점은 둘 다 소프트웨어의 외부 계약을 다룬다는 점입니다. 하지만, 식별할 수 있는 동작은 소프트웨어가 실제로 수행하는 행위의 관찰 가능한 측면에 초점을 맞추는 반면, 인터페이스는 상호작용의 명세와 규칙에 더 집중합니다. 결국, 둘 다 소프트웨어의 사용성과 예측 가능성을 보장하는 데 중요한 역할을 하지만, 접근 방식과 초점에 차이가 있습니다.
