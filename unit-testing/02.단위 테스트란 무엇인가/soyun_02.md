### 2.1 단위테스트의 정의

- 단위테스트란?
    - 작은 코드조각을 검증하고
    - 빠르게 수행하고 → 그리 중요한 내용은 아님 테스트 스위트의 실행시간이 충분하면 충분히 빠른 것
    - 격리된 방식으로 처리하는 자동화된 테스트

세 번째 속성이 의견이 갈린다. 

격리문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이에 속한다. 

격리가 정확히 무엇인가? 의견차이로 나뉜다. 

(저자는 고전적 스타일을 선호한다)

단위 테스트의 고전파와 런던파

- 고전파 classcial school:
    - 개념적: 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식이기에 고전
    - 고전적 접근법을 디트로이트Detroit 라고도 한다
- 런던파 London school:
    - 개념적: 런던의 프로그래밍 커뮤니티에서 시작됨
    - 런턴 스타일은 목 추종자mockist로도 표현된다.

### 2.1.1 격리 문제에 대한 런던파 접근

런던파에서는 테스트 대상 시스템을 협력자collaborator에게서 격리하는 것으로 보았다.

클래스의 모든 의존성을 테스트 대역test double로 대체해 

동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있게 한다.

- 장점
    - 테스트 실패하면 코드베이스의 어느부분이 고장났는지 확실히 알 수 있다
    - 객체 그래프(object graph 같은 문제를 해결하는 클래스들의 통신망)를 분할할 수 있다.
    - 테스트 대상 클래스를 의존성에서 분리하면 단순한 테스트 스위트 구조(제품 코드의 각 클래스에 대해 테스트클래스가 하나씩 있는 구조)를 확립하는데 도움된다.

단위 테스트의 고전스타일에서는 협력자를 대체하지 않고 운영용 인스턴스를 사용한다. 

### 2.1.2 격리문제에 대한 고전파 접근

“런던 스타일”은 테스트 대역(목)으로 테스트 대상 코드 조각을 분리해서 격리 요구사항에 다가간다. 

이처럼 모든 클래스를 격리하기 위해서 테스트 대상 코드 조각은 단일 클래스이거나 해당 클래스 내의 메서드여야한다. 

“고전적 방법” 은 격리특성을 다르게 해석한다. 

코드를 반드시 격리하기보다 단위 테스트를 서로 격리해서 실행한다. 

각각의 테스트를 격리하면 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한번에 테스트해도 상관없기 때문이다. 이를 통해 테스트가 서로 소통하고 실행 컨텍스트에 영항을 줄 수 없다. 

(공유상태란 데이터베이스, 파일시스템 등 프로세스 외부 의존성이 이렇게 공유상태인 경우를 말한다. )

단위 테스트를 서로 격리하는 것은 테스트 대상 클래스에서 공유 의존성만 격리하는 것을 의미한다. 

비공개 의존성은 그대로 둘 수 있다

실행 프로세스 외부에 있는 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 오래 걸린다. 

단위 테스트 두 번째 속성으로 빨리 실행해야하는 필요성이 있다.

반드시 단위가 클래스에 국한될 필요없이 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수도 있다. 

<aside>
💡 공유의존성, 비공개 의존성, 프로세스 외부 의존성

- 공유의존성 shared dependency : 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
    - 예) 정적 가변 필드 static mutable field
    - 필드 변경 사항은 동일한 프로세스 내에서 실행되는 모든 단위테스트에서 볼 수 있다.
    - 데이터베이스도 공유 의존성의 예가 될 수 있다.
- 비공개 의존성 private dependency : 공유하지 않는 의존성
- 프로세스 외부 의존성 out-of-process dependency : 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
    - 대부분 공유 의존성에 해당되지만  다 그런것은 아니다
    - 데이터베이스는 프로세스 외부이면서 의존성이지만 만약 각 테스트 실행전에 도커 컨테이너로 디비를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 공유하지 않는 의존성이 된다.

공유 의존성과 휘발성 의존성
휘발성 의존성은 다음 속성 중 하나를 나타내는 위존성이다. 

- 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다. 데이터베이스와 API서비스가 좋은 예다. 추가 설정이 필요하며 시스템에 기본으로 설치돼 있지 않다.
- 비결정적 동작 (예) 난수 생성기 반환하는 클래스, 호출할 때마다 다른 결과 제공)
</aside>

### 2.2 단위 테스트의 런던파와 고전파

런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보고

고전파는 단위 테스트끼리 격리하는 것으로 본다. 

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |

### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

런던파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 한다. 

불변 객체 (값 객체 Value Object) 

내용에 의해서만 식별되기 때문에 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다(인스턴스는 서로 바꿔 사용할 수 있다)

<aside>
💡 읽어보기

- [ ]  엔티티 대 값 객체: 궁극적인 차이점 목록

https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/

</aside>

비공개 의존성은 변경 가능하거나 불변일 수 있다

### 2.3 고전파와 런던파의 비교

둘의 차이는 격리문제를 어떻게 다루느냐에서 비롯되어

- 테스트해야 할 단위의 처리
- 의존성 취급

에 대한 방법으로 넘어간다

런던파의 접근 방식을 사용할 경우의 장점

- 입자성granularity이 좋다. 테스트가 세밀함
- 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다
- 테스트 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다

### 2.3.1 한번에 한 클래스만 테스트하기

런던파는 클래스 단위로 테스트한다.

좋은 코드 입자성을 목표로 하는 것은 도움되지 않고 

테스트가 단일 동작 단위를 검증하는 것이 좋은 테스트이다. 

더 세부적인 단위로 테스트를 하면 무엇을 검증하는지 정확히 이해하기 어렵기 때문에 좋지 않다.  

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

실제 협력자를 대신해 목을 사용하면 테스트를 쉽게 테스트할 수 있다. 

하지만 상호 연결된 클래스들을 어떻게 테스트할 지 방법을 찾는 것은 별로 도움되지 않는다. 그 대신

이러한 클래스 그래프를 갖지 않는데 집중해야한다. 대체로 클래스 그래프가 커진 것은 코드 설계 문제의 결과이다. 

목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다. 

### 2.3.4 고전파와 런던파 사이의 다른 차이점

남아있는 두 가지 차이점

- 테스트 주도 개발 TDD (Test-Driven test)
- 과도한 명세over-specification 문제

런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대키를 설정하는 상위 레벨 테스트부터 시작한다. 

고전파는 테스트에서 실제 객체를 다뤄야하기 때문에 일반적으로 상향식으로 한다. 도메인 모델을 시작으로 최종 사용자가 소프트웨어를  사용할 수 있을 때까지 계층을 그 위에 더 둔다. 

### 2.4 두 분파의 통합 테스트

런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다

고전 스타일로 작성된 테스트를 보며 런던 던지지자들에게 통합 테스트로 느껴질 것이다. 

런던파

- 작은 코드 조각 검증
- 빠르게 수행
- 격리된 방식으로 처리

고전파

- 단일 동작 단위를 검증
- 빠르게 수행
- 다른 테스트와 별도로 처리

통합테스트는 이러한 기준 중 하나를 충족하지 않는 테스트이다. 

예를 들면 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다. 

둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트다.

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다. 

엔드 투 엔드 테스트는 통합 테스트의 일부이다.

둘의 차이점은 엔드 투 엔드 테스트가 일반적으로 의존성을 더 많이 포함한다는 것이다.

일반적으로 통합테스트는 프로세스 외부 의존성을 한 두개만 갖고 작동한다. 반면에 엔드 투 엔드 테스트는 외부 의존성을 전부 또는 대 다수 갖고 작동한다. 따라서 엔드 투 엔드라는 명칭은 모든 외부 애플리케이션을 포함해 시스템을 최존 사용자의 관점에서 검증하는 것을 의미한다.

엔드 투 엔드 테스트는 유지보수 측면에서 가장 비용이 많이 들어가기 때문에 모든 단위 테스트와 통합 테스트를 통합 괗 나 후에 빌드 프로세스 후반에 실행하는 것이 좋다.
