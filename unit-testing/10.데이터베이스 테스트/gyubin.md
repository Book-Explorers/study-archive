# 10. 데이터베이스 테스트

## 10장에서 다루는 내용

- 데이터베이스 테스트를 위한 전제 조건
- 데이터베이스 테스트 모범 사례
- 테스트 데이터 생명 주기
- 테스트 내 데이터베이스 트랜잭션 관리

## 데이터베이스 테스트를 위한 전제 조건

통합 테스트에서는 관리 의존성(애플리케이션을 통해서만 접근 가능한 곳)에는 목을 사용해서는 안된다. 이 절에서는 다음과 같은 전제 조건을 살펴본다.

- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 데이터베이스를 형상 관리 시스템에 유지

데이터베이스 스키마는 Git과 같은 형상 관리 시스템에 저장하는 것이 최선이다. 변경 사항이 저장되는 모델 데이터베이스를 사용하는 방법은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다. 그 이유는 다음과 같다.

- 변경 내역 부재
    - 데이터베이스 스키마를 과거의 특정 시점을 되돌릴 수 없다. 이는 운영 환경에서 버그를 재현할 때 중요할 수 있다.
    - 복수의 원천 정보
        - 모델 데이터베이스 개발 상태에 대한 원천 정보를 둘러싸고 경합하게 된다.

반면 모든 데이터베이스 스키마 업데이트를 형상 관리 시스템에 두면 원천 정보를 하나로 유지할 수 있고, 데이터베이스에 대한 변경을 추적할 수 있다.

❗️형상 관리 외부에서는 데이터베이스 구조를 수정하면 안 된다.

참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터다. 그렇기 때문에 데이터베이서 스키마와 함께 SQL INSERT 문 형태로 형상 관리 시스템에 필수로 저장해야 한다.

### 모든 개발자를 위한 별도의 데이터베이스 인스턴스

공유 데이터베이스를 사용하면 개발 프로세스를 방해하게 된다. 그 이유는 다음과 같다.

- 서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문이다.
- 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있기 때문이다.

테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용해야한다.

### 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포

- 상태 기반 방식
    - 데이터베이스를 작성하는 데 사용할 수 있는 SQL 스크립트가 형상 관리 시스템에 저장되며, 운영 데이터베이스 상태와 관계없이 불필요한 테이블을 삭제하고 새 테이블을 생성하고 컬럼명을 바꾸는 등 모델 데이터베이스와 동기화하는 데 필요한 모든 작업을 수행한다.
    - 마이그레이션을 암묵적으로 제어한다.
- 마이그레이션 기반 방식
    - 데이터베이스를 다른 버전으로 전환하는 명시적인 마이그레이션을 의미한다.
    - 데이터베이스를 자동으로 동기화하기 위해 업그레이드 스크립트를 직접 작성해야 한다.
    - 상태 기반 방식과 다르게 형상 관리 시스템에서 저장하는 데이터는 상태가 아니라 마이그레이션 정보다.
    - 대표적으로 flywaydb가 있다.

## 데이터베이스 트랜잭션 관리

통합 테스트에서 테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위(ex: JPA EntityManager)를 재사용하지 말아야 한다. 예를 들면 JPA Entity Manager를 재사용하게 되면 Persistence Context에 캐싱된 entity가 조회가 되기 때문에 검증 구절에서 제대로된 검증을 할 수 없게 된다.

## 테스트 데이터 생명 주기

통합 테스트의 실행 속도를 향상 시키기 위해 테스트를 병렬로 처리하는 것 보다 순차적으로 처리하는 것이 더 실용적이다. 병렬 처리로 인해 얻는 것 보다 잃는 것이 더 많다. 그래도 통합 테스트를 병렬 처리하고 싶다면 테스트 컨테이를 사용하자.

### 테스트 실행 간 데이터 정리

- 각 테스트 전에 데이터베이스 백업 복원하기
- 테스트 종료 시점에 데이터 정리하기
- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
    - test method에 @Transaction을 사용하는 방법
    - 트랜잭션이 분리되어 있다면 자식 트랜잭션에서 커밋된 내용은 롤백이 안되기 때문에 주의해야 한다.
- **테스트 시작 시점에 데이터 정리하기**

JUnit5를 사용한다면 @BeforeEach, @AfterEach를 통해 데이터를 셋업하고 정리할 수 있다.

### 인메모리 데이터베이스 피하기

MySQL과 H2의 동작이 100프로 같지 않기 때문에 운영 데이터베이스를 MySQL을 사용한다면 테스트 시 H2와 같은 인메모리 데이터베이스의 사용은 피해야한다.

### 테스트 구절에서 코드 재사용하기

@BeforeEach로 테스트 픽스처를 사용하면 픽스처를 수정하였을 때 이를 사용하고 있는 테스트 코드는 깨지기 쉬운 테스트 코드가 될 수 있다. 테스트 준비 구절 간에 코드를 재사용하기에 가장 좋은 방법은 비공개 팩토리 메서드를 도입하는 것이다. 같은 클래스내에 비공개 팩토리 메서드를 만들어 사용하다가 많은 곳에서 비슷한 코드가 사용 된다면 별도의 클래스로 분리하여 사용하면 된다.

## 데이터베이스 테스트에 대한 일반적인 질문

### 읽기 테스트를 해야 하는가?

데이터베이스 쓰기(저장, 수정, 삭제)에 대한 테스트는 철저히 하는 것이 좋다. 테스트를 통해 잘못된 부분을 빨리 찾아 데이터베이스에 잘못된 데이터가 쓰여지는 것을 방지해야되기 때문이다. 그러나 읽기에 대한 테스트는 가장 복잡한 읽기 작업에 대한 테스트만 따로 작성하고 나머지는 통합 테스트의 일부로 취급 되어야 한다.