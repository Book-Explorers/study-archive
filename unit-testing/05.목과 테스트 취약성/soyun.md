<aside>
💡 목과 스텁 구분
식별할 수 있는 동작과 구현 세부 사항 정의
목과 테스트 취약성 간의 관계 이해
리팩터링 내성 저하 없이 목 사용

</aside>

테스트에서 목을 사용하는 것은 논란의 여지가 있는 주제다. 

목이 리팩터링 내성이 부족한 취약한 테스트를 초래하는 것을 살펴보고 또 리팩터링 내성 저하 없이 목을 사용하는 방법도 살펴보자. 

1. 목과 스텁 구분

테스트 대역은 모든 유형의 비운영용 가짜 의존성을 말하는 포괄적 용어다. 

테스트를 편리하게 해주는 것이 주 용도로  실제 의존성 대신 전달된다.

테스트 대역은 더미, 스텁, 스파이,목,페이크 다섯가지가 있지만 크게 목과 스텁 두 가지 유형으로 나눌 수 있다. 

- 목은 **외부로 나가는 상호 작용을 모방하고 검사하는데 사용된다**. 이러한 상호작용은 sut테스트대상 시스템이 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
    - 목은 sut와 관련된 의존성 간의 상호작용을 모방하고 검사하는 반면
- 스텁은 **내부에서 들어오는 상호작용을 모방하는데 도움된다.** 이러한 상호작용은 sut가 입력데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
    - 스텁은 모방만 한다.
    - 주어진 입력에 대한 출력을 제공하는지 테스트한다

이메일 발송은 smtp 서버에 사이드 이펙트를 초래하는 외부로 나가는 상호작용이다. 목은 이러한 상호작용을 모방하는 테스트 대역에 해당한다. 

데이터베이스에서 데이터를 검색하는 것은 내부로 들어오는 상호작요이다. 이것은 사이드 이펙트를 일으키지 않는다. 해당 테스트 대역은 스텁이다. 

1. 도구로서의 목과 테스트 대역으로서의 목

mock 목은 

목 라이브러리의 클래스는 실제 목을 만드는데 도움은 되지만 그 자체로는 목이 아니다. 

도구로서의 목을 사용해 목과 스텁 두가지 유형의 테스트 대역을 생성할 수 있기 때문에

도구로서의 목과 테스트 대역으로서의 목을 혼동하지 않는 것이 좋다. 

1. 스텁으로 상호작용을 검증하지 말라. 

스텁은 내부로 들어오는 상호작용만 모방하고 검증하지 않는다. 이와 달리 목은 sut에서 관련 의존성으로 나가는 상호작용을 모방하고 검사한다. 스텁이 모방하는 것은 내부 구현 세부사항이다. 이러한 내부구현에 대한 호출을 검증하는 것은 테스트 취약성으로 이어질 수 있다.

1. 목과 스텁함께 쓰기

때로는 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다. 

준비된 응답을 반환하고 sut에서 수행한 메서드 호출을 검증한다. 

1. 목과 스텁은 명령과 조회에 어떻게 관련되어 있는가

모든 메서드는 명령이거나 조회여야한다. 

명령은 사이드 이펙트(객체 변경, 파일변경등)를 일으키고 어떤 값도 반환하지 않는 메서드다. 

조회는 그 반대로 사이드 이펙트가 없고 값을 반환한다. 

명령을 대체하는 테스트 대역은 목이다. 

조회를 대체하는 테스트 대역은 스텁이다. 

1. 식별할 수 있는 동작과 구현 세부 사항

리팩터링 내성 지표는 좋은 단위 테스트의 중요한 특성이다. 

결합을 낮추는 방법은 코드가 생성하는 최종결과(식별할 수 있는 동작)를 검증하고

구현 세부 사항과 테스트를 떨어뜨리는 것이다. 

즉 테스트는 어떻게가 아니라 무엇에 중점을 두어야한다. 

1. 식별할 수 있는 동작은 공개 api와 다르다

식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다. 

코드가 시스템의 식별할 수 있는 동작이라면 다음 중 하나를 해야한다. 

- 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드다.
- 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.

구현 세부 사항은 이 두 가지 중 아무것도 하지 않는다. 

이상적으로 시스템의 공개 api는 식별할 수 있는 동작과 일치해야하며 구현 세부 사항은 눈에 보여서는 안된다. 하지만 종종 공개 api가 식별할 수 있는 동작의 범위를 넘어설 때가 있는데 이경우 시스템은 구현 세부 사항을 유출한다. 이 경우 불변성이 위반된다. 마찬가지로 캡슐화가 깨지게 된다. 

클라이언트가  구현세부사항에 접근해 불변성을 우회할 수 있기 때문이다. 

코드 베이스 유지 보수를 위해 캡슐화가 중요하다. 코드 복잡도를 줄여야한다. 

“묻지 말고 말하라”

데이터를 연산기능과 결합하는 것을 의미한다. 구현 세부사항을 숨기고 데이터와 기능을 결합하는 것을 말한다. 

연산과 상태 노출을 최소한으로 하고 

클라이언트가 목표를 달성하는데 직접적으로 도움이 되는 코드만 공개해야한다.

모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없으며 이로 인해 리팩터링 내성도 좋아진다. 

1. 목과 테스트 취약성 간의 관계

육각형 아키텍쳐 정의

전형적인 애플리케이션은 도메인, 애플리케이션 서비스라는 두 계층으로 구성된다. 

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다. (도메인 클래스와 프로세스 외부 의존성간의 작업을 조정)

이 둘의 조합은 육각형을 형성한다. 

육각형 아키텍쳐는

- 도메인 애플리케이션 서비스 계층 간의 영향 분리
    - 도메인 계층은 비즈니스 로직을 책임
    - 애플리케이션 서비스는 도메인 계층과 외부 애플리케이션 간의 작업을 조정한다.
- 애플리케이션 서비스 계층에서 도메인 계층으로의 단반향 의존성 흐름
- 도메인 계층 내 클래스는 서로에게만 의존해야한다.

육각형 계층은 식별할 수 있는 동작을 나타내며 각각의 구현 세부 사항이 있다.

애플리케이션에는 시스템 내부 통신과 시스템 간 통신이라는 두 가지 통신 유형이 있다. 

- 시스템 내부 통신은 애플리케이션 클래스 간이 통신
- 시스템 간 통신은 애플리케이션이 외부 애플리케이션과 통신할 때 말한다

시스템 내 통신은 구현 세부 사항이다. 애플리케이션을 통해서만 접근할 수 있는 외부 시스템을 제외하고 시스템 간 통신을 식별할 수 있는 동작이다. 애플리케이션을 통해서만 접근할 수 있는 외부 시스템과의 상호작용도 구현 세부사항인데 그 결과의 사이드 이펙트를 외부에서 확인할 수 없기 때문이다.                                                                                                                                                  

시스템 내 통신을 검증하고자 목을 사용하면 취약한 테스트로 이어진다. 따라서 시스템 간 통신과 해당 통신의 사이드 이펙트가 외부 환경에서 보일 때만 목을 사용하는 것이 타당하다. 

**애플리케이션 내부와 외부 통신 차이를 이해하는 것은 테스트 전략을 수립할 때 중요하다.** 

1. 고전파와 런던파

런던파는 불변의존성을 제외한 모든 의존성에 목 사용을 권장하고 시스템 내 통신과 시스템 간 통신을 구분하지 않는다. 그 결과 구현과 결합되 테스트에 리팩터링 내성이 없게 된다. 

고전파는 테스트 간에 공유하는 의존성만 교체하자고 하기에 리팩터링 내성에 유리하다. 하지만 고전파도 목사용을 장려하고 있긴하다. 

1. 모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다. 

의존성 유형은 다음과 같다. 

- 공유 의존성: 테스트 간에 공유하는 의존성 (제품코드가 아님)
- 프로세스 외부 의존성: 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성 (데이터베이스, 메시지 버스, SMTP서비스 등)
- 비공개 의존성: 공유하지 않는 모은 의존성
